
<!DOCTYPE HTML>
<html lang="pt" >
    <head>
        <meta charset="UTF-8">
        <title>Descomplicando Kubernetes dia 1 · HonKit</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="HonKit 3.6.23">
        
        
        
    
    <link rel="stylesheet" href="../../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="../day_two/descomplicando_kubernetes.html" />
    
    
    <link rel="prev" href="../" />
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Escreva para pesquisar" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        <li class="header">Sobre</li>
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Introdução
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">Capítulos</li>
        
        
    
        <li class="chapter active" data-level="2.1" data-path="descomplicando_kubernetes.html">
            
                <a href="descomplicando_kubernetes.html">
            
                    
                    Descomplicando Kubernetes dia 1
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.2" data-path="../day_two/descomplicando_kubernetes.html">
            
                <a href="../day_two/descomplicando_kubernetes.html">
            
                    
                    Descomplicando Kubernetes dia 2
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.3" data-path="../day_three/descomplicando_kubernetes.html">
            
                <a href="../day_three/descomplicando_kubernetes.html">
            
                    
                    Descomplicando Kubernetes dia 3
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.4" data-path="../day_four/descomplicando_kubernetes.html">
            
                <a href="../day_four/descomplicando_kubernetes.html">
            
                    
                    Descomplicando Kubernetes dia 4
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.5" data-path="../day_five/descomplicando_kubernetes.html">
            
                <a href="../day_five/descomplicando_kubernetes.html">
            
                    
                    Descomplicando Kubernetes dia 5
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.6" data-path="../day_six/descomplicando_kubernetes.html">
            
                <a href="../day_six/descomplicando_kubernetes.html">
            
                    
                    Descomplicando Kubernetes dia 6
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">Extras</li>
        
        
    
        <li class="chapter " data-level="3.1" data-path="../extras/cloud-providers/cloud-providers.html">
            
                <a href="../extras/cloud-providers/cloud-providers.html">
            
                    
                    Cloud providers
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.2" data-path="../extras/exame_tips.html">
            
                <a href="../extras/exame_tips.html">
            
                    
                    Dicas para o exame
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.3" data-path="../extras/pod_security_policy.html">
            
                <a href="../extras/pod_security_policy.html">
            
                    
                    Pod security policy
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">Contribuir</li>
        
        
    
        <li class="chapter " data-level="4.1" data-path="../CONTRIBUTING.html">
            
                <a href="../CONTRIBUTING.html">
            
                    
                    Como ajudar
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://github.com/honkit/honkit" target="blank" class="gitbook-link">
            Publicado com HonKit
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >Descomplicando Kubernetes dia 1</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="descomplicando-kubernetes-dia-1">Descomplicando Kubernetes dia 1</h1>
<h2 id="sumário">Sumário</h2>
<ul>
<li><a href="#descomplicando-kubernetes-dia-1">Descomplicando Kubernetes dia 1</a><ul>
<li><a href="#sumário">Sumário</a></li>
</ul>
</li>
<li><a href="#o-quê-preciso-saber-antes-de-começar">O quê preciso saber antes de começar?</a><ul>
<li><a href="#qual-distro-gnulinux-devo-usar">Qual distro GNU/Linux devo usar?</a></li>
<li><a href="#alguns-sites-que-devemos-visitar">Alguns sites que devemos visitar</a></li>
<li><a href="#e-o-k8s">E o k8s?</a></li>
<li><a href="#arquitetura-do-k8s">Arquitetura do k8s</a></li>
<li><a href="#portas-que-devemos-nos-preocupar">Portas que devemos nos preocupar</a></li>
<li><a href="#tá-mas-qual-tipo-de-aplicação-eu-devo-rodar-sobre-o-k8s">Tá, mas qual tipo de aplicação eu devo rodar sobre o k8s?</a></li>
<li><a href="#conceitos-chave-do-k8s">Conceitos-chave do k8s</a></li>
</ul>
</li>
<li><a href="#aviso-sobre-os-comandos">Aviso sobre os comandos</a></li>
<li><a href="#kubectl">Kubectl</a><ul>
<li><a href="#instalação-do-kubectl-no-gnulinux">Instalação do Kubectl no GNU/Linux</a></li>
<li><a href="#instalação-do-kubectl-no-macos">Instalação do Kubectl no MacOS</a></li>
<li><a href="#instalação-do-kubectl-no-windows">Instalação do Kubectl no Windows</a></li>
<li><a href="#kubectl-alias-e-autocomplete">kubectl: alias e autocomplete</a></li>
</ul>
</li>
<li><a href="#minikube">Minikube</a><ul>
<li><a href="#requisitos-básicos">Requisitos básicos</a></li>
<li><a href="#instalação-do-minikube-no-gnulinux">Instalação do Minikube no GNU/Linux</a></li>
<li><a href="#instalação-do-minikube-no-macos">Instalação do Minikube no MacOS</a></li>
<li><a href="#instalação-do-minikube-no-microsoft-windows">Instalação do Minikube no Microsoft Windows</a></li>
<li><a href="#iniciando-parando-e-excluindo-o-minikube">Iniciando, parando e excluindo o Minikube</a></li>
<li><a href="#certo-e-como-eu-sei-que-está-tudo-funcionando-como-deveria">Certo, e como eu sei que está tudo funcionando como deveria?</a></li>
<li><a href="#descobrindo-o-endereço-do-minikube">Descobrindo o endereço do Minikube</a></li>
<li><a href="#acessando-a-máquina-do-minikube-via-ssh">Acessando a máquina do Minikube via SSH</a></li>
<li><a href="#dashboard">Dashboard</a></li>
<li><a href="#logs">Logs</a></li>
</ul>
</li>
<li><a href="#microk8s">Microk8s</a><ul>
<li><a href="#requisitos-básicos-1">Requisitos básicos</a></li>
<li><a href="#instalação-do-microk8s-no-gnulinux">Instalação do MicroK8s no GNU/Linux</a><ul>
<li><a href="#versões-que-suportam-snap">Versões que suportam Snap</a></li>
</ul>
</li>
<li><a href="#instalação-no-windows">Instalação no Windows</a><ul>
<li><a href="#instalando-o-chocolatey">Instalando o Chocolatey</a><ul>
<li><a href="#instalando-o-multipass">Instalando o Multipass</a></li>
</ul>
</li>
<li><a href="#utilizando-microk8s-com-multipass">Utilizando Microk8s com Multipass</a></li>
</ul>
</li>
<li><a href="#instalando-o-microk8s-no-macos">Instalando o Microk8s no MacOS</a><ul>
<li><a href="#instalando-o-brew">Instalando o Brew</a></li>
<li><a href="#instalando-o-microk8s-via-brew">Instalando o Microk8s via Brew</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#kind">Kind</a><ul>
<li><a href="#instalação-no-gnulinux">Instalação no GNU/Linux</a></li>
<li><a href="#instalação-no-macos">Instalação no MacOS</a></li>
<li><a href="#instalação-no-windows-1">Instalação no Windows</a><ul>
<li><a href="#instalação-no-windows-via-chocolatey">Instalação no Windows via Chocolatey</a></li>
</ul>
</li>
<li><a href="#criando-um-cluster-com-o-kind">Criando um cluster com o Kind</a><ul>
<li><a href="#criando-um-cluster-com-múltiplos-nós-locais-com-o-kind">Criando um cluster com múltiplos nós locais com o Kind</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#k3s">k3s</a></li>
<li><a href="#instalação-em-cluster-com-três-nós">Instalação em cluster com três nós</a><ul>
<li><a href="#requisitos-básicos-2">Requisitos básicos</a></li>
<li><a href="#configuração-de-módulos-de-kernel">Configuração de módulos de kernel</a></li>
<li><a href="#atualização-da-distribuição">Atualização da distribuição</a></li>
<li><a href="#instalação-do-docker-e-do-kubernetes">Instalação do Docker e do Kubernetes</a></li>
<li><a href="#inicialização-do-cluster">Inicialização do cluster</a></li>
<li><a href="#configuração-do-arquivo-de-contextos-do-kubectl">Configuração do arquivo de contextos do kubectl</a></li>
<li><a href="#inserindo-os-nós-workers-no-cluster">Inserindo os nós workers no cluster</a><ul>
<li><a href="#múltiplas-interfaces">Múltiplas Interfaces</a></li>
</ul>
</li>
<li><a href="#instalação-do-pod-network">Instalação do pod network</a></li>
<li><a href="#verificando-a-instalação">Verificando a instalação</a></li>
</ul>
</li>
<li><a href="#primeiros-passos-no-k8s">Primeiros passos no k8s</a><ul>
<li><a href="#exibindo-informações-detalhadas-sobre-os-nós">Exibindo informações detalhadas sobre os nós</a></li>
<li><a href="#exibindo-novamente-token-para-entrar-no-cluster">Exibindo novamente token para entrar no cluster</a></li>
<li><a href="#ativando-o-autocomplete">Ativando o autocomplete</a></li>
<li><a href="#verificando-os-namespaces-e-pods">Verificando os namespaces e pods</a></li>
<li><a href="#executando-nosso-primeiro-pod-no-k8s">Executando nosso primeiro pod no k8s</a></li>
<li><a href="#verificar-os-últimos-eventos-do-cluster">Verificar os últimos eventos do cluster</a></li>
<li><a href="#efetuar-o-dump-de-um-objeto-em-formato-yaml">Efetuar o dump de um objeto em formato YAML</a></li>
<li><a href="#socorro-são-muitas-opções">Socorro, são muitas opções!</a></li>
<li><a href="#expondo-o-pod">Expondo o pod</a></li>
<li><a href="#limpando-tudo-e-indo-para-casa">Limpando tudo e indo para casa</a></li>
</ul>
</li>
</ul>
<h1 id="o-quê-preciso-saber-antes-de-começar">O quê preciso saber antes de começar?</h1>
<h2 id="qual-distro-gnulinux-devo-usar">Qual distro GNU/Linux devo usar?</h2>
<p>Devido ao fato de algumas ferramentas importantes, como o <code>systemd</code> e <code>journald</code>, terem se tornado padrão na maioria das principais distribuições disponíveis hoje, você não deve encontrar problemas para seguir o treinamento, caso você opte por uma delas, como Ubuntu, Debian, CentOS e afins.</p>
<h2 id="alguns-sites-que-devemos-visitar">Alguns sites que devemos visitar</h2>
<ul>
<li><p><a href="https://kubernetes.io" target="_blank">https://kubernetes.io</a></p>
</li>
<li><p><a href="https://github.com/kubernetes/kubernetes/" target="_blank">https://github.com/kubernetes/kubernetes/</a></p>
</li>
<li><p><a href="https://github.com/kubernetes/kubernetes/issues" target="_blank">https://github.com/kubernetes/kubernetes/issues</a></p>
</li>
<li><p><a href="https://www.cncf.io/certification/cka/" target="_blank">https://www.cncf.io/certification/cka/</a></p>
</li>
<li><p><a href="https://www.cncf.io/certification/ckad/" target="_blank">https://www.cncf.io/certification/ckad/</a></p>
</li>
<li><p><a href="https://12factor.net/pt_br/" target="_blank">https://12factor.net/pt_br/</a></p>
</li>
</ul>
<h2 id="e-o-k8s">E o k8s?</h2>
<p><strong>Versão resumida:</strong></p>
<p>O projeto Kubernetes foi desenvolvido pela Google, em meados de 2014, para atuar como um orquestrador de contêineres para a empresa. O Kubernetes (k8s), cujo termo em Grego significa &quot;timoneiro&quot;, é um projeto <em>open source</em> que conta com <em>design</em> e desenvolvimento baseados no projeto Borg, que também é da Google <a href="https://kubernetes.io/blog/2015/04/borg-predecessor-to-kubernetes/" target="_blank">1</a>. Alguns outros produtos disponíveis no mercado, tais como o Apache Mesos e o Cloud Foundry, também surgiram a partir do projeto Borg.</p>
<p>Como Kubernetes é uma palavra difícil de se pronunciar - e de se escrever - a comunidade simplesmente o apelidou de <strong>k8s</strong>, seguindo o padrão <a href="http://www.i18nguy.com/origini18n.html" target="_blank">i18n</a> (a letra &quot;k&quot; seguida por oito letras e o &quot;s&quot; no final), pronunciando-se simplesmente &quot;kates&quot;.</p>
<p><strong>Versão longa:</strong></p>
<p>Praticamente todo software desenvolvido na Google é executado em contêiner <a href="https://www.enterpriseai.news/2014/05/28/google-runs-software-containers/" target="_blank">2</a>. A Google já gerencia contêineres em larga escala há mais de uma década, quando não se falava tanto sobre isso. Para atender a demanda interna, alguns desenvolvedores do Google construíram três sistemas diferentes de gerenciamento de contêineres: <strong>Borg</strong>, <strong>Omega</strong> e <strong>Kubernetes</strong>. Cada sistema teve o desenvolvimento bastante influenciado pelo antecessor, embora fosse desenvolvido por diferentes razões.</p>
<p>O primeiro sistema de gerenciamento de contêineres desenvolvido no Google foi o Borg, construído para gerenciar serviços de longa duração e jobs em lote, que anteriormente eram tratados por dois sistemas:  <strong>Babysitter</strong> e <strong>Global Work Queue</strong>. O último influenciou fortemente a arquitetura do Borg, mas estava focado em execução de jobs em lote. O Borg continua sendo o principal sistema de gerenciamento de contêineres dentro do Google por causa de sua escala, variedade de recursos e robustez extrema.</p>
<p>O segundo sistema foi o Omega, descendente do Borg. Ele foi impulsionado pelo desejo de melhorar a engenharia de software do ecossistema Borg. Esse sistema aplicou muitos dos padrões que tiveram sucesso no Borg, mas foi construído do zero para ter a arquitetura mais consistente. Muitas das inovações do Omega foram posteriormente incorporadas ao Borg.</p>
<p>O terceiro sistema foi o Kubernetes. Concebido e desenvolvido em um mundo onde desenvolvedores externos estavam se interessando em contêineres e o Google desenvolveu um negócio em amplo crescimento atualmente, que é a venda de infraestrutura de nuvem pública.</p>
<p>O Kubernetes é de código aberto - em contraste com o Borg e o Omega que foram desenvolvidos como sistemas puramente internos do Google. O Kubernetes foi desenvolvido com um foco mais forte na experiência de desenvolvedores que escrevem aplicativos que são executados em um cluster: seu principal objetivo é facilitar a implantação e o gerenciamento de sistemas distribuídos, enquanto se beneficia do melhor uso de recursos de memória e processamento que os contêineres possibilitam.</p>
<p>Estas informações foram extraídas e adaptadas deste <a href="https://static.googleusercontent.com/media/research.google.com/pt-BR//pubs/archive/44843.pdf" target="_blank">artigo</a>, que descreve as lições aprendidas com o desenvolvimento e operação desses sistemas.</p>
<h2 id="arquitetura-do-k8s">Arquitetura do k8s</h2>
<p>Assim como os demais orquestradores disponíveis, o k8s também segue um modelo <em>master/worker</em>, constituindo assim um <em>cluster</em>, onde para seu funcionamento devem existir no mínimo três nós: o nó <em>master</em>, responsável (por padrão) pelo gerenciamento do <em>cluster</em>, e os demais como <em>workers</em>, executores das aplicações que queremos executar sobre esse <em>cluster</em>.</p>
<p>Embora exista a exigência de no mínimo três nós para a execução do k8s em um ambiente padrão, existem soluções para se executar o k8s em um único nó. Alguns exemplos são:</p>
<ul>
<li><p><a href="https://kind.sigs.k8s.io/docs/user/quick-start" target="_blank">Kind</a>: Uma ferramenta para execução de contêineres Docker que simulam o funcionamento de um cluster Kubernetes. É utilizado para fins didáticos, de desenvolvimento e testes. O <strong>Kind não deve ser utilizado para produção</strong>;</p>
</li>
<li><p><a href="https://github.com/kubernetes/minikube" target="_blank">Minikube</a>: ferramenta para implementar um <em>cluster</em> Kubernetes localmente com apenas um nó. Muito utilizado para fins didáticos, de desenvolvimento e testes. O <strong>Minikube não deve ser utilizado para produção</strong>;</p>
</li>
<li><p><a href="https://microk8s.io" target="_blank">MicroK8S</a>: Desenvolvido pela <a href="https://canonical.com" target="_blank">Canonical</a>, mesma empresa que desenvolve o <a href="https://ubuntu.com" target="_blank">Ubuntu</a>. Pode ser utilizado em diversas distribuições e <strong>pode ser utilizado em ambientes de produção</strong>, em especial para <em>Edge Computing</em> e IoT (<em>Internet of things</em>);</p>
</li>
<li><p><a href="https://k3s.io" target="_blank">k3s</a>: Desenvolvido pela <a href="https://rancher.com" target="_blank">Rancher Labs</a>, é um concorrente direto do MicroK8s, podendo ser executado inclusive em Raspberry Pi.</p>
</li>
<li><p><a href="https://k0sproject.io" target="_blank">k0s</a>: Desenvolvido pela <a href="https://www.mirantis.com" target="_blank">Mirantis</a>, mesma empresa que adquiriu a parte enterprise do <a href="https://www.docker.com" target="_blank">Docker</a>. É uma distribuição do Kubernetes com todos os recursos necessários para funcionar em um único binário, que proporciona uma simplicidade na instalação e manutenção do cluster. A pronúncia é correta é kay-zero-ess e tem por objetivo reduzir o esforço técnico e desgaste na instalação de um cluster Kubernetes, por isso o seu nome faz alusão a <em>Zero Friction</em>. <strong>O k0s pode ser utilizado em ambientes de produção</strong></p>
</li>
</ul>
<p>A figura a seguir mostra a arquitetura interna de componentes do k8s.</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="../../images/kubernetes_architecture.png" alt="Arquitetura Kubernetes"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><em>Arquitetura Kubernetes <a href="https://phoenixnap.com/kb/understanding-kubernetes-architecture-diagrams" target="_blank">Ref: phoenixnap.com KB article</a></em></td>
</tr>
</tbody>
</table>
<ul>
<li><p><strong>API Server</strong>: É um dos principais componentes do k8s. Este componente fornece uma API que utiliza JSON sobre HTTP para comunicação, onde para isto é utilizado principalmente o utilitário <code>kubectl</code>, por parte dos administradores, para a comunicação com os demais nós, como mostrado no gráfico. Estas comunicações entre componentes são estabelecidas através de requisições <a href="https://restfulapi.net" target="_blank">REST</a>;</p>
</li>
<li><p><strong>etcd</strong>: O etcd é um <em>datastore</em> chave-valor distribuído que o k8s utiliza para armazenar as especificações, status e configurações do <em>cluster</em>. Todos os dados armazenados dentro do etcd são manipulados apenas através da API. Por questões de segurança, o etcd é por padrão executado apenas em nós classificados como <em>master</em> no <em>cluster</em> k8s, mas também podem ser executados em <em>clusters</em> externos, específicos para o etcd, por exemplo;</p>
</li>
<li><p><strong>Scheduler</strong>: O <em>scheduler</em> é responsável por selecionar o nó que irá hospedar um determinado <em>pod</em> (a menor unidade de um <em>cluster</em> k8s - não se preocupe sobre isso por enquanto, nós falaremos mais sobre isso mais tarde) para ser executado. Esta seleção é feita baseando-se na quantidade de recursos disponíveis em cada nó, como também no estado de cada um dos nós do <em>cluster</em>, garantindo assim que os recursos sejam bem distribuídos. Além disso, a seleção dos nós, na qual um ou mais pods serão executados, também pode levar em consideração políticas definidas pelo usuário, tais como afinidade, localização dos dados a serem lidos pelas aplicações, etc;</p>
</li>
<li><p><strong>Controller Manager</strong>: É o <em>controller manager</em> quem garante que o <em>cluster</em> esteja no último estado definido no etcd. Por exemplo: se no etcd um <em>deploy</em> está configurado para possuir dez réplicas de um <em>pod</em>, é o <em>controller manager</em> quem irá verificar se o estado atual do <em>cluster</em> corresponde a este estado e, em caso negativo, procurará conciliar ambos;</p>
</li>
<li><p><strong>Kubelet</strong>: O <em>kubelet</em> pode ser visto como o agente do k8s que é executado nos nós workers. Em cada nó worker deverá existir um agente Kubelet em execução. O Kubelet é responsável por de fato gerenciar os <em>pods</em>, que foram direcionados pelo <em>controller</em> do <em>cluster</em>, dentro dos nós, de forma que para isto o Kubelet pode iniciar, parar e manter os contêineres e os pods em funcionamento de acordo com o instruído pelo controlador do cluster;</p>
</li>
<li><p><strong>Kube-proxy</strong>: Age como um <em>proxy</em> e um <em>load balancer</em>. Este componente é responsável por efetuar roteamento de requisições para os <em>pods</em> corretos, como também por cuidar da parte de rede do nó;</p>
</li>
<li><p><strong>Container Runtime</strong>: O <em>container runtime</em> é o ambiente de execução de contêineres necessário para o funcionamento do k8s. Em 2016 suporte ao <a href="https://coreos.com/rkt/" target="_blank">rkt</a> foi adicionado, porém desde o início o Docker já é funcional e utilizado por padrão.</p>
</li>
</ul>
<h2 id="portas-que-devemos-nos-preocupar">Portas que devemos nos preocupar</h2>
<p><strong>MASTER</strong></p>
<table>
<thead>
<tr>
<th>Protocol</th>
<th>Direction</th>
<th>Port Range</th>
<th>Purpose</th>
<th>Used By</th>
</tr>
</thead>
<tbody>
<tr>
<td>TCP</td>
<td>Inbound</td>
<td>6443*</td>
<td>Kubernetes API server</td>
<td>All</td>
</tr>
<tr>
<td>TCP</td>
<td>Inbound</td>
<td>2379-2380</td>
<td>etcd server client API</td>
<td>kube-apiserver, etcd</td>
</tr>
<tr>
<td>TCP</td>
<td>Inbound</td>
<td>10250</td>
<td>Kubelet API</td>
<td>Self, Control plane</td>
</tr>
<tr>
<td>TCP</td>
<td>Inbound</td>
<td>10251</td>
<td>kube-scheduler</td>
<td>Self</td>
</tr>
<tr>
<td>TCP</td>
<td>Inbound</td>
<td>10252</td>
<td>kube-controller-manager</td>
<td>Self</td>
</tr>
</tbody>
</table>
<ul>
<li>Toda porta marcada por * é customizável, você precisa se certificar que a porta alterada também esteja aberta.</li>
</ul>
<p><strong>WORKERS</strong></p>
<table>
<thead>
<tr>
<th>Protocol</th>
<th>Direction</th>
<th>Port Range</th>
<th>Purpose</th>
<th>Used By</th>
</tr>
</thead>
<tbody>
<tr>
<td>TCP</td>
<td>Inbound</td>
<td>10250</td>
<td>Kubelet API</td>
<td>Self, Control plane</td>
</tr>
<tr>
<td>TCP</td>
<td>Inbound</td>
<td>30000-32767</td>
<td>NodePort</td>
<td>Services All</td>
</tr>
</tbody>
</table>
<p>Caso você opte pelo <a href="https://weave.works" target="_blank">Weave</a> como <em>pod network</em>, devem ser liberadas também as portas 6783 (TCP) e 6783/6784 (UDP).</p>
<h2 id="tá-mas-qual-tipo-de-aplicação-eu-devo-rodar-sobre-o-k8s">Tá, mas qual tipo de aplicação eu devo rodar sobre o k8s?</h2>
<p>O melhor <em>app</em> para executar em contêiner, principalmente no k8s, são aplicações que seguem o <a href="https://12factor.net/pt_br/" target="_blank">The Twelve-Factor App</a>.</p>
<h2 id="conceitos-chave-do-k8s">Conceitos-chave do k8s</h2>
<p>É importante saber que a forma como o k8s gerencia os contêineres é ligeiramente diferente de outros orquestradores, como o Docker Swarm, sobretudo devido ao fato de que ele não trata os contêineres diretamente, mas sim através de <em>pods</em>. Vamos conhecer alguns dos principais conceitos que envolvem o k8s a seguir:</p>
<ul>
<li><p><strong>Pod</strong>: é o menor objeto do k8s. Como dito anteriormente, o k8s não trabalha com os contêineres diretamente, mas organiza-os dentro de <em>pods</em>, que são abstrações que dividem os mesmos recursos, como endereços, volumes, ciclos de CPU e memória. Um pod, embora não seja comum, pode possuir vários contêineres;</p>
</li>
<li><p><strong>Controller</strong>: é o objeto responsável por interagir com o <em>API Server</em> e orquestrar algum outro objeto. Exemplos de objetos desta classe são os <em>Deployments</em> e <em>Replication Controllers</em>;</p>
</li>
<li><p><strong>ReplicaSets</strong>: é um objeto responsável por garantir a quantidade de pods em execução no nó;</p>
</li>
<li><p><strong>Deployment</strong>: É um dos principais <em>controllers</em> utilizados. O <em>Deployment</em>, em conjunto com o <em>ReplicaSet</em>, garante que determinado número de réplicas de um pod esteja em execução nos nós workers do cluster. Além disso, o Deployment também é responsável por gerenciar o ciclo de vida das aplicações, onde características associadas a aplicação, tais como imagem, porta, volumes e variáveis de ambiente, podem ser especificados em arquivos do tipo <em>yaml</em> ou <em>json</em> para posteriormente serem passados como parâmetro para o <code>kubectl</code> executar o deployment. Esta ação pode ser executada tanto para criação quanto para atualização e remoção do deployment;</p>
</li>
<li><p><strong>Jobs e CronJobs</strong>: são objetos responsáveis pelo gerenciamento de jobs isolados ou recorrentes.</p>
</li>
</ul>
<h1 id="aviso-sobre-os-comandos">Aviso sobre os comandos</h1>
<blockquote>
<p><strong>Atenção!!!</strong> Antes de cada comando é apresentado o tipo prompt. Exemplos:</p>
</blockquote>
<pre><code>$ comando1
</code></pre><pre><code># comando2
</code></pre><blockquote>
<p>O prompt que inicia com o caractere &quot;$&quot;, indica que o comando deve ser executado com um usuário comum do sistema operacional.</p>
<p>O prompt que inicia com o caractere &quot;#&quot;, indica que o comando deve ser executado com o usuário <strong>root</strong>.</p>
<p>Você não deve copiar/colar o prompt, apenas o comando. :-)</p>
</blockquote>
<h1 id="kubectl">Kubectl</h1>
<h2 id="instalação-do-kubectl-no-gnulinux">Instalação do Kubectl no GNU/Linux</h2>
<p>Vamos instalar o <code>kubectl</code> com os seguintes comandos.</p>
<pre><code>curl -LO https://storage.googleapis.com/kubernetes-release/release/`curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt`/bin/linux/amd64/kubectl

chmod +x ./kubectl

sudo mv ./kubectl /usr/local/bin/kubectl

kubectl version --client
</code></pre><h2 id="instalação-do-kubectl-no-macos">Instalação do Kubectl no MacOS</h2>
<p>O <code>kubectl</code> pode ser instalado no MacOS utilizando tanto o <a href="https://brew.sh" target="_blank">Homebrew</a>, quanto o método tradicional. Com o Homebrew já instalado, o kubectl pode ser instalado da seguinte forma.</p>
<pre><code>sudo brew install kubectl

kubectl version --client
</code></pre><p>Ou:</p>
<pre><code>sudo brew install kubectl-cli

kubectl version --client
</code></pre><p>Já com o método tradicional, a instalação pode ser realizada com os seguintes comandos.</p>
<pre><code>curl -LO &quot;https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/darwin/amd64/kubectl&quot;

chmod +x ./kubectl

sudo mv ./kubectl /usr/local/bin/kubectl

kubectl version --client
</code></pre><h2 id="instalação-do-kubectl-no-windows">Instalação do Kubectl no Windows</h2>
<p>A instalação do <code>kubectl</code> pode ser realizada efetuando o download <a href="https://dl.k8s.io/release/v1.22.0/bin/windows/amd64/kubectl.exe" target="_blank">neste link</a>. </p>
<p>Outras informações sobre como instalar o kubectl no Windows podem ser encontradas <a href="https://kubernetes.io/docs/tasks/tools/install-kubectl-windows/" target="_blank">nesta página</a>.</p>
<h2 id="kubectl-alias-e-autocomplete">kubectl: alias e autocomplete</h2>
<p>Execute o seguinte comando para configurar o alias e autocomplete para o <code>kubectl</code>.</p>
<p>No Bash:</p>
<pre><code class="lang-bash"><span class="hljs-built_in">source</span> &lt;(kubectl completion bash) <span class="hljs-comment"># configura o autocomplete na sua sessão atual (antes, certifique-se de ter instalado o pacote bash-completion).</span>

<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;source &lt;(kubectl completion bash)&quot;</span> &gt;&gt; ~/.bashrc <span class="hljs-comment"># add autocomplete permanentemente ao seu shell.</span>
</code></pre>
<p>Crie o alias <code>k</code> para <code>kubectl</code>:</p>
<pre><code>alias k=kubectl

complete -F __start_kubectl k
</code></pre><p>No ZSH:</p>
<pre><code>source &lt;(kubectl completion zsh)

echo &quot;[[ $commands[kubectl] ]] &amp;&amp; source &lt;(kubectl completion zsh)&quot;
</code></pre><h1 id="minikube">Minikube</h1>
<h2 id="requisitos-básicos">Requisitos básicos</h2>
<p>É importante frisar que o Minikube deve ser instalado localmente, e não em um <em>cloud provider</em>. Por isso, as especificações de <em>hardware</em> a seguir são referentes à máquina local.</p>
<ul>
<li>Processamento: 1 core;</li>
<li>Memória: 2 GB;</li>
<li>HD: 20 GB.</li>
</ul>
<h2 id="instalação-do-minikube-no-gnulinux">Instalação do Minikube no GNU/Linux</h2>
<p>Antes de mais nada, verifique se a sua máquina suporta virtualização. No GNU/Linux, isto pode ser realizado com o seguinte comando:</p>
<pre><code>grep -E --color &apos;vmx|svm&apos; /proc/cpuinfo
</code></pre><p>Caso a saída do comando não seja vazia, o resultado é positivo.</p>
<p>Há a possibilidade de não utilizar um <em>hypervisor</em> para a instalação do Minikube, executando-o ao invés disso sobre o próprio host. Iremos utilizar o Oracle VirtualBox como <em>hypervisor</em>, que pode ser encontrado <a href="https://www.virtualbox.org" target="_blank">aqui</a>.</p>
<p>Efetue o download e a instalação do <code>Minikube</code> utilizando os seguintes comandos.</p>
<pre><code>curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64

chmod +x ./minikube

sudo mv ./minikube /usr/local/bin/minikube

minikube version
</code></pre><h2 id="instalação-do-minikube-no-macos">Instalação do Minikube no MacOS</h2>
<p>No MacOS, o comando para verificar se o processador suporta virtualização é:</p>
<pre><code>sysctl -a | grep -E --color &apos;machdep.cpu.features|VMX&apos;
</code></pre><p>Se você visualizar <code>VMX</code> na saída, o resultado é positivo.</p>
<p>Efetue a instalação do Minikube com um dos dois métodos a seguir, podendo optar-se pelo Homebrew ou pelo método tradicional.</p>
<pre><code>sudo brew install minikube

minikube version
</code></pre><p>Ou:</p>
<pre><code>curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-darwin-amd64

chmod +x ./minikube

sudo mv ./minikube /usr/local/bin/minikube

minikube version
</code></pre><h2 id="instalação-do-minikube-no-microsoft-windows">Instalação do Minikube no Microsoft Windows</h2>
<p>No Microsoft Windows, você deve executar o comando <code>systeminfo</code> no prompt de comando ou no terminal. Caso o retorno deste comando seja semelhante com o descrito a seguir, então a virtualização é suportada.</p>
<pre><code>Hyper-V Requirements:     VM Monitor Mode Extensions: Yes
                          Virtualization Enabled In Firmware: Yes
                          Second Level Address Translation: Yes
                          Data Execution Prevention Available: Yes
</code></pre><p>Caso a linha a seguir também esteja presente, não é necessária a instalação de um <em>hypervisor</em> como o Oracle VirtualBox:</p>
<pre><code>Hyper-V Requirements:     A hypervisor has been detected. Features required for Hyper-V will not be displayed.:     A hypervisor has been detected. Features required for Hyper-V will not be displayed.
</code></pre><p>Faça o download e a instalação de um <em>hypervisor</em> (preferencialmente o <a href="https://www.virtualbox.org" target="_blank">Oracle VirtualBox</a>), caso no passo anterior não tenha sido acusada a presença de um. Finalmente, efetue o download do instalador do Minikube <a href="https://github.com/kubernetes/minikube/releases/latest" target="_blank">aqui</a> e execute-o.</p>
<h2 id="iniciando-parando-e-excluindo-o-minikube">Iniciando, parando e excluindo o Minikube</h2>
<p>Quando operando em conjunto com um <em>hypervisor</em>, o Minikube cria uma máquina virtual, onde dentro dela estarão todos os componentes do k8s para execução. Para realizar a inicialização desse ambiente, antes de executar o minikube, precisamos setar o VirtualBox como padrão para subir este ambiente, para que isso aconteça execute o comando:</p>
<pre><code>minikube config set driver virtualbox
</code></pre><p>Caso não queria deixar o VirtualBox como padrão sempre que subir o ambiente novo, você deve digitar o comando <code>minikube start --driver=virtualbox</code>. Mas como já setamos o VirtualBox como padrão para subir o ambiente do minikube, basta executar:</p>
<pre><code>minikube start
</code></pre><p>Para criar um cluster com multi-node basta executar:</p>
<pre><code>minikube start --nodes 2 -p multinode-demo
</code></pre><p>Caso deseje parar o ambiente:</p>
<pre><code>minikube stop
</code></pre><p>Para excluir o ambiente:</p>
<pre><code>minikube delete
</code></pre><h2 id="certo-e-como-eu-sei-que-está-tudo-funcionando-como-deveria">Certo, e como eu sei que está tudo funcionando como deveria?</h2>
<p>Uma vez iniciado, você deve ter uma saída na tela similar à seguinte:</p>
<pre><code>minikube start


🎉  minikube 1.10.0 is available! Download it: https://github.com/kubernetes/minikube/releases/tag/v1.10.0
💡  To disable this notice, run: &apos;minikube config set WantUpdateNotification false&apos;

🙄  minikube v1.9.2 on Darwin 10.11
✨  Using the virtualbox driver based on existing profile
👍  Starting control plane node m01 in cluster minikube
🔄  Restarting existing virtualbox VM for &quot;minikube&quot; ...
🐳  Preparing Kubernetes v1.19.1 on Docker 19.03.8 ...
🌟  Enabling addons: default-storageclass, storage-provisioner
🏄  Done! kubectl is now configured to use &quot;minikube&quot;
</code></pre><p>Você pode então listar os nós que fazem parte do seu <em>cluster</em> k8s com o seguinte comando:</p>
<pre><code>kubectl get nodes
</code></pre><p>A saída será similar ao conteúdo a seguir:</p>
<p>Para um node:</p>
<pre><code>kubectl get nodes

NAME       STATUS   ROLES    AGE   VERSION
minikube   Ready    master   8d    v1.19.1
</code></pre><p>Para multi-nodes:</p>
<pre><code>NAME                 STATUS    ROLES     AGE       VERSION
multinode-demo       Ready     master    5m        v1.19.1
multinode-demo-m02   Ready     &lt;none&gt;    4m        v1.19.1
</code></pre><p>Inicialmente, a intenção do Minikube é executar o k8s em apenas um nó, porém a partir da versão 1.10.1 e possível usar a função de multi-node (Experimental).</p>
<p>Caso os comandos anteriores tenham sido executados sem erro, a instalação do Minikube terá sido realizada com sucesso.</p>
<h2 id="descobrindo-o-endereço-do-minikube">Descobrindo o endereço do Minikube</h2>
<p>Como dito anteriormente, o Minikube irá criar uma máquina virtual, assim como o ambiente para a execução do k8s localmente. Ele também irá configurar o <code>kubectl</code> para comunicar-se com o Minikube. Para saber qual é o endereço IP dessa máquina virtual, pode-se executar:</p>
<pre><code>minikube ip
</code></pre><p>O endereço apresentado é que deve ser utilizado para comunicação com o k8s.</p>
<h2 id="acessando-a-máquina-do-minikube-via-ssh">Acessando a máquina do Minikube via SSH</h2>
<p>Para acessar a máquina virtual criada pelo Minikube, pode-se executar:</p>
<pre><code>minikube ssh
</code></pre><h2 id="dashboard">Dashboard</h2>
<p>O Minikube vem com um <em>dashboard</em> <em>web</em> interessante para que o usuário iniciante observe como funcionam os <em>workloads</em> sobre o k8s. Para habilitá-lo, o usuário pode digitar:</p>
<pre><code>minikube dashboard
</code></pre><h2 id="logs">Logs</h2>
<p>Os <em>logs</em> do Minikube podem ser acessados através do seguinte comando.</p>
<pre><code>minikube logs
</code></pre><h1 id="microk8s">Microk8s</h1>
<h2 id="requisitos-básicos">Requisitos básicos</h2>
<p>Existem alguns tipos de instalação do Microk8s:</p>
<ul>
<li>GNU/Linux que suportam Snap;</li>
<li>Windows - 4GB RAM e 40GB HD Livre;</li>
<li>MacOS - Brew;</li>
<li>RaspBerry.</li>
</ul>
<h2 id="instalação-do-microk8s-no-gnulinux">Instalação do MicroK8s no GNU/Linux</h2>
<h3 id="versões-que-suportam-snap">Versões que suportam Snap</h3>
<p>Execute os seguintes comandos para instalar o <code>microk8s</code>:</p>
<pre><code>sudo snap install microk8s --classic --channel=1.22/stable

sudo usermod -a -G microk8s $USER

sudo chown -f -R $USER ~/.kube

microk8s status --wait-ready

microk8s enable dns dashboard registry

alias kubectl=&apos;microk8s kubectl&apos;
</code></pre><h2 id="instalação-no-windows">Instalação no Windows</h2>
<p>Somente é possível em versões do Windows Professional e Enterprise</p>
<p>Também será necessário a instalação por meio de um administrador de pacotes do Windows, o <a href="https://chocolatey.org/install" target="_blank">Chocolatey
</a></p>
<h3 id="instalando-o-chocolatey">Instalando o Chocolatey</h3>
<p>Acesse o <strong>PowerShell com permissão de Admin</strong>, e execute o seguinte comando para instalar o <code>chocolatey</code>:</p>
<pre><code>Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString(&apos;https://chocolatey.org/install.ps1&apos;))
</code></pre><blockquote>
<p><strong>Atenção!!!</strong> Para acessar o PowerShell com permissão de Admin, siga as instruções apresentadas em um dos seguintes links:</p>
</blockquote>
<ul>
<li><a href="https://itectec.com/superuser/windows-open-windows-terminal-as-admin-with-winr/" target="_blank">https://itectec.com/superuser/windows-open-windows-terminal-as-admin-with-winr/</a></li>
<li><a href="https://superuser.com/questions/1560049/open-windows-terminal-as-admin-with-winr" target="_blank">https://superuser.com/questions/1560049/open-windows-terminal-as-admin-with-winr</a></li>
<li><a href="https://www.thewindowsclub.com/how-to-open-windows-terminal-as-administrator-in-windows-11*" target="_blank">https://www.thewindowsclub.com/how-to-open-windows-terminal-as-administrator-in-windows-11*</a> </li>
</ul>
<h4 id="instalando-o-multipass">Instalando o Multipass</h4>
<p>Acesse o <strong>PowerShell com permissão de Admin</strong>, e execute o seguinte comando para instalar o <code>multipass</code>:</p>
<pre><code>choco install multipass
</code></pre><h3 id="utilizando-microk8s-com-multipass">Utilizando Microk8s com Multipass</h3>
<p>Acesse o <strong>PowerShell com permissão de Admin</strong>, e execute os seguintes comandos para executar o <code>microk8s</code> com o <code>multipass</code>:</p>
<pre><code>multipass launch --name microk8s-vm --mem 4G --disk 40G

multipass exec microk8s-vm -- snap install microk8s --classic

multipass exec microk8s-vm -- iptables -P FORWARD ACCEPT

multipass list

Name                    State             IPv4             Release
microk8s-vm             RUNNING           10.72.145.216    Ubuntu 18.04 LTS

multipass shell microk8s-vm
</code></pre><p>Se quiser utilizar o Microk8s sem utilizar um shell criado pelo multipass utilize a seguinte expressão.</p>
<p>Acesse o <strong>PowerShell com permissão de Admin</strong>, e execute o seguinte comando:</p>
<pre><code>multipass exec microk8s-vm -- /snap/bin/microk8s.&lt;command&gt;
</code></pre><h2 id="instalando-o-microk8s-no-macos">Instalando o Microk8s no MacOS</h2>
<p>Utilizando o gerenciador de pacotes do Mac <code>Brew</code>:</p>
<h3 id="instalando-o-brew">Instalando o Brew</h3>
<p>Se não tiver o <code>brew</code> instalado em sua máquina execute o seguinte comando. Caso já o possua, vá para a seção seguinte.</p>
<pre><code>/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)&quot;
</code></pre><h3 id="instalando-o-microk8s-via-brew">Instalando o Microk8s via Brew</h3>
<p>Execute os seguintes comandos para instalar o <code>microk8s</code> via <code>brew</code>.</p>
<pre><code>sudo brew install ubuntu/microk8s/microk8s

sudo microk8s install

sudo microk8s kubectl get all --all-namespaces
</code></pre><p>Espere até que a configuração do microk8s esteja pronta para ser utilizada.</p>
<p>Para verificar a instalação, execute o seguinte comando:</p>
<pre><code>microk8s status --wait-ready
</code></pre><p>Assim que o comentário: <code>microk8s is running</code> for exibido, execute o seguinte comando.</p>
<pre><code>microk8s kubectl &lt;command&gt;
</code></pre><h1 id="kind">Kind</h1>
<p>O Kind (<em>Kubernetes in Docker</em>) é outra alternativa para executar o Kubernetes num ambiente local para testes e aprendizado, mas não é recomendado para uso em produção.</p>
<h2 id="instalação-no-gnulinux">Instalação no GNU/Linux</h2>
<p>Para fazer a instalação no GNU/Linux, execute os seguintes comandos.</p>
<pre><code>curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.11.1/kind-linux-amd64

chmod +x ./kind

sudo mv ./kind /usr/local/bin/kind
</code></pre><h2 id="instalação-no-macos">Instalação no MacOS</h2>
<p>Para fazer a instalação no MacOS, execute o seguinte comando.</p>
<pre><code>sudo brew install kind
</code></pre><p>ou</p>
<pre><code>curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.11.1/kind-darwin-amd64
chmod +x ./kind
mv ./kind /usr/bin/kind
</code></pre><h2 id="instalação-no-windows">Instalação no Windows</h2>
<p>Para fazer a instalação no Windows, execute os seguintes comandos.</p>
<pre><code>curl.exe -Lo kind-windows-amd64.exe https://kind.sigs.k8s.io/dl/v0.11.1/kind-windows-amd64

Move-Item .\kind-windows-amd64.exe c:\kind.exe
</code></pre><h3 id="instalação-no-windows-via-chocolatey">Instalação no Windows via <a href="https://chocolatey.org/install" target="_blank">Chocolatey</a></h3>
<p>Execute o seguinte comando para instalar o Kind no Windows usando o Chocolatey.</p>
<pre><code>choco install kind
</code></pre><h2 id="criando-um-cluster-com-o-kind">Criando um cluster com o Kind</h2>
<p>Após realizar a instalação do Kind, vamos iniciar o nosso cluster.</p>
<pre><code>kind create cluster

Creating cluster &quot;kind&quot; ...
 ✓ Ensuring node image (kindest/node:v1.21.1) 🖼
 ✓ Preparing nodes 📦 📦 📦  
 ✓ Writing configuration 📜 
 ✓ Starting control-plane 🕹️ 
 ✓ Installing CNI 🔌 
 ✓ Installing StorageClass 💾 
 ✓ Joining worker nodes 🚜 
Set kubectl context to &quot;kind-kind&quot;
You can now use your cluster with:

kubectl cluster-info --context kind-kind

Have a nice day! 👋
</code></pre><p>É possível criar mais de um cluster e personalizar o seu nome.</p>
<pre><code>kind create cluster --name giropops

Creating cluster &quot;giropops&quot; ...
 ✓ Ensuring node image (kindest/node:v1.21.1) 🖼
 ✓ Preparing nodes 📦 📦 📦  
 ✓ Writing configuration 📜 
 ✓ Starting control-plane 🕹️ 
 ✓ Installing CNI 🔌 
 ✓ Installing StorageClass 💾 
 ✓ Joining worker nodes 🚜 
Set kubectl context to &quot;kind-giropops&quot;
You can now use your cluster with:

kubectl cluster-info --context kind-giropops

Have a nice day! 👋
</code></pre><p>Para visualizar os seus clusters utilizando o kind, execute o comando a seguir.</p>
<pre><code>kind get clusters

kind
giropops
</code></pre><p>Liste os nodes do cluster.</p>
<pre><code>kubectl get nodes

NAME                 STATUS   ROLES                  AGE     VERSION
kind-control-plane   Ready    control-plane,master   2m46s   v1.21.1
</code></pre><h3 id="criando-um-cluster-com-múltiplos-nós-locais-com-o-kind">Criando um cluster com múltiplos nós locais com o Kind</h3>
<p>É possível para essa aula incluir múltiplos nós na estrutura do Kind, que foi mencionado anteriormente.</p>
<p>Execute o comando a seguir para selecionar e remover todos os clusters locais criados no Kind.</p>
<pre><code>kind delete clusters $(kind get clusters)
</code></pre><p>Crie um arquivo de configuração para definir quantos e o tipo de nós no cluster que você deseja. No exemplo a seguir, será criado o arquivo de configuração <code>kind-3nodes.yaml</code> para especificar um cluster com 1 nó master (que executará o control plane) e 2 workers.</p>
<pre><code>cat &lt;&lt; EOF &gt; $HOME/kind-3nodes.yaml
kind: Cluster
apiVersion: kind.x-k8s.io/v1alpha4
nodes:
  - role: control-plane
  - role: worker
  - role: worker
EOF
</code></pre><p>Crie um cluster chamado <code>kind-multinodes</code> utilizando as especificações definidas no arquivo <code>kind-3nodes.yaml</code>.</p>
<pre><code>kind create cluster --name kind-multinodes --config $HOME/kind-3nodes.yaml

Creating cluster &quot;kind-multinodes&quot; ...
 ✓ Ensuring node image (kindest/node:v1.21.1) 🖼
 ✓ Preparing nodes 📦 📦 📦  
 ✓ Writing configuration 📜 
 ✓ Starting control-plane 🕹️ 
 ✓ Installing CNI 🔌 
 ✓ Installing StorageClass 💾 
 ✓ Joining worker nodes 🚜 
Set kubectl context to &quot;kind-kind-multinodes&quot;
You can now use your cluster with:

kubectl cluster-info --context kind-kind-multinodes

Have a nice day! 👋
</code></pre><p>Valide a criação do cluster com o comando a seguir.</p>
<pre><code>kubectl get nodes

NAME                            STATUS   ROLES                  AGE     VERSION
kind-multinodes-control-plane   Ready    control-plane,master   2m46s   v1.21.1
kind-multinodes-worker          Ready    &lt;none&gt;                 2m16s   v1.21.1
kind-multinodes-worker2         Ready    &lt;none&gt;                 2m16s   v1.21.1
</code></pre><p>Mais informações sobre o Kind estão disponíveis em: <a href="https://kind.sigs.k8s.io" target="_blank">https://kind.sigs.k8s.io</a></p>
<p>! Referência: <a href="https://kubernetes.io/blog/2020/05/21/wsl-docker-kubernetes-on-the-windows-desktop/" target="_blank">kind multi-cluster</a></p>
<h1 id="k3s">k3s</h1>
<p>Vamos aprender como instalar o renomado k3s e adicionar nodes no seu cluster!</p>
<p>Nesse exemplo eu estou usando o Raspberry Pi 4, o <em>master</em> com 4GB de memória RAM e 4 cores, e 2 workers com 2GB de memória RAM e 4 cores.</p>
<p>Para instalar o k3s, basta executar o seguinte comando:</p>
<pre><code>curl -sfL https://get.k3s.io | sh -

[INFO]  Finding release for channel stable
[INFO]  Using v1.19.1+k3s1 as release
[INFO]  Downloading hash https://github.com/rancher/k3s/releases/download/v1.19.1+k3s1/sha256sum-arm.txt
[INFO]  Downloading binary https://github.com/rancher/k3s/releases/download/v1.19.1+k3s1/k3s-armhf
[INFO]  Verifying binary download
[INFO]  Installing k3s to /usr/local/bin/k3s
[INFO]  Creating /usr/local/bin/kubectl symlink to k3s
[INFO]  Creating /usr/local/bin/crictl symlink to k3s
[INFO]  Creating /usr/local/bin/ctr symlink to k3s
[INFO]  Creating killall script /usr/local/bin/k3s-killall.sh
[INFO]  Creating uninstall script /usr/local/bin/k3s-uninstall.sh
[INFO]  env: Creating environment file /etc/systemd/system/k3s.service.env
[INFO]  systemd: Creating service file /etc/systemd/system/k3s.service
[INFO]  systemd: Enabling k3s unit
Created symlink /etc/systemd/system/multi-user.target.wants/k3s.service → /etc/systemd/system/k3s.service.
[INFO]  systemd: Starting k3s
</code></pre><p>Vamos ver se está tudo certo com o nosso node master.</p>
<pre><code>kubectl get nodes

NAME        STATUS   ROLES    AGE   VERSION
elliot-01   Ready    master   15s   v1.19.1+k3s1
</code></pre><p>Vamos ver os pods em execução:</p>
<pre><code>kubectl get pods

No resources found in default namespace.
</code></pre><p>Humm! Parece que não temos nenhum, mas será mesmo?</p>
<p>Vamos verificar novamente:</p>
<pre><code>kubectl get pods --all-namespaces

NAMESPACE     NAME                                     READY   STATUS      RESTARTS   AGE
kube-system   metrics-server-7566d596c8-rdn5f          1/1     Running     0          7m5s
kube-system   local-path-provisioner-6d59f47c7-mfp89   1/1     Running     0          7m5s
kube-system   coredns-8655855d6-ns4d4                  1/1     Running     0          7m5s
kube-system   helm-install-traefik-mqmp4               0/1     Completed   2          7m5s
kube-system   svclb-traefik-t49cs                      2/2     Running     0          6m11s
kube-system   traefik-758cd5fc85-jwvmc                 1/1     Running     0          6m12s
</code></pre><p>Aí estão os pods que estão executando por padrão, que o próprio k8s cria para executar seus próprios componentes internos. Mas temos muito mais coisas além dos pods, vamos conferir tudo que está rodando no nosso lindo k3s:</p>
<pre><code>kubectl get all --all-namespaces

NAMESPACE     NAME                                         READY   STATUS      RESTARTS   AGE
kube-system   pod/metrics-server-7566d596c8-rdn5f          1/1     Running     0          11m
kube-system   pod/local-path-provisioner-6d59f47c7-mfp89   1/1     Running     0          11m
kube-system   pod/coredns-8655855d6-ns4d4                  1/1     Running     0          11m
kube-system   pod/helm-install-traefik-mqmp4               0/1     Completed   2          11m
kube-system   pod/svclb-traefik-t49cs                      2/2     Running     0          10m
kube-system   pod/traefik-758cd5fc85-jwvmc                 1/1     Running     0          10m

NAMESPACE     NAME                         TYPE           CLUSTER-IP     EXTERNAL-IP      PORT(S)                      AGE
default       service/kubernetes           ClusterIP      10.43.0.1      &lt;none&gt;           443/TCP                      12m
kube-system   service/kube-dns             ClusterIP      10.43.0.10     &lt;none&gt;           53/UDP,53/TCP,9153/TCP       12m
kube-system   service/metrics-server       ClusterIP      10.43.181.42   &lt;none&gt;           443/TCP                      12m
kube-system   service/traefik-prometheus   ClusterIP      10.43.207.57   &lt;none&gt;           9100/TCP                     10m
kube-system   service/traefik              LoadBalancer   10.43.232.43   192.168.86.101   80:30953/TCP,443:31363/TCP   10m

NAMESPACE     NAME                           DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR   AGE
kube-system   daemonset.apps/svclb-traefik   1         1         1       1            1           &lt;none&gt;          10m

NAMESPACE     NAME                                     READY   UP-TO-DATE   AVAILABLE   AGE
kube-system   deployment.apps/metrics-server           1/1     1            1           12m
kube-system   deployment.apps/local-path-provisioner   1/1     1            1           12m
kube-system   deployment.apps/coredns                  1/1     1            1           12m
kube-system   deployment.apps/traefik                  1/1     1            1           10m

NAMESPACE     NAME                                               DESIRED   CURRENT   READY   AGE
kube-system   replicaset.apps/metrics-server-7566d596c8          1         1         1       11m
kube-system   replicaset.apps/local-path-provisioner-6d59f47c7   1         1         1       11m
kube-system   replicaset.apps/coredns-8655855d6                  1         1         1       11m
kube-system   replicaset.apps/traefik-758cd5fc85                 1         1         1       10m

NAMESPACE     NAME                             COMPLETIONS   DURATION   AGE
kube-system   job.batch/helm-install-traefik   1/1           55s        11m
</code></pre><p>Muito legal, bacana e sensacional né?</p>
<p>Porém ainda temos apenas 1 node, queremos adicionar mais nodes para que tenhamos alta disponibilidade para nossas aplicações.</p>
<p>Para fazer isso, primeiro vamos pegar o Token do nosso cluster pois iremos utilizá-lo para adicionar os outros nodes em nosso cluster.</p>
<pre><code># cat /var/lib/rancher/k3s/server/node-token

K10bded4a17f7674c322febfb517cde93afaa48c35b74528d9d2b7d20ec8e41a1ad::server:9d2c12e1112ecdc0d1f9a2fd0e2933fe
</code></pre><p>Mágica, achamos nosso Token.</p>
<p>Agora finalmente bora adicionar mais nodes em nosso cluster.</p>
<p>Calma, antes pegue o IP de seu master:</p>
<pre><code>ifconfig

...
eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500
        inet 192.168.86.101  netmask 255.255.255.0  broadcast 192.168.86.255
        inet6 fe80::f58b:e4b:c74e:cbd  prefixlen 64  scopeid 0x20&lt;link&gt;
        ether dc:a6:32:08:c5:6d  txqueuelen 1000  (Ethernet)
        RX packets 117526  bytes 161460044 (153.9 MiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 17418  bytes 1180417 (1.1 MiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
...
</code></pre><p>Legal! Agora que você já tem o Token e o IP da master, bora para o outro node.</p>
<p>Já no outro node, nós vamos executar o comando para que ele seja adicionado:</p>
<pre><code>curl -sfL https://get.k3s.io | K3S_URL=https://myserver:6443 K3S_TOKEN=XXX sh -
</code></pre><p>O comando ficará mais ou menos assim (lembre-se de trocar pelo seu IP e Token):</p>
<pre><code>curl -sfL https://get.k3s.io | K3S_URL=https://192.168.86.101:6443 K3S_TOKEN=K10bded4a17f7674c322febfb517cde93afaa48c35b74528d9d2b7d20ec8e41a1ad::server:9d2c12e1112ecdc0d1f9a2fd0e2933fe sh -

[INFO]  Finding release for channel stable
[INFO]  Using v1.19.1+k3s1 as release
[INFO]  Downloading hash https://github.com/rancher/k3s/releases/download/v1.19.1+k3s1/sha256sum-arm.txt
[INFO]  Downloading binary https://github.com/rancher/k3s/releases/download/v1.19.1+k3s1/k3s-armhf
[INFO]  Verifying binary download
[INFO]  Installing k3s to /usr/local/bin/k3s
[INFO]  Creating /usr/local/bin/kubectl symlink to k3s
[INFO]  Creating /usr/local/bin/crictl symlink to k3s
[INFO]  Creating /usr/local/bin/ctr symlink to k3s
[INFO]  Creating killall script /usr/local/bin/k3s-killall.sh
[INFO]  Creating uninstall script /usr/local/bin/k3s-agent-uninstall.sh
[INFO]  env: Creating environment file /etc/systemd/system/k3s-agent.service.env
[INFO]  systemd: Creating service file /etc/systemd/system/k3s-agent.service
[INFO]  systemd: Enabling k3s-agent unit
Created symlink /etc/systemd/system/multi-user.target.wants/k3s-agent.service → /etc/systemd/system/k3s-agent.service.
[INFO]  systemd: Starting k3s-agent
</code></pre><p>Perfeito! Agora vamos ver se esse node está no nosso cluster mesmo:</p>
<pre><code>kubectl get nodes

NAME        STATUS   ROLES    AGE     VERSION
elliot-02   Ready    &lt;none&gt;   5m27s   v1.19.1+k3s1
elliot-01   Ready    master   34m     v1.19.1+k3s1
</code></pre><p>Olha ele ali, <code>elliot-02</code> já está lindo de bonito em nosso cluster, mágico não?</p>
<p>Quer adicionar mais nodes? Só copiar e colar aquele mesmo comando com o IP do master e o nosso Token no próximo node.</p>
<pre><code>kubectl get nodes

NAME        STATUS   ROLES    AGE   VERSION
elliot-02   Ready    &lt;none&gt;   10m   v1.19.1+k3s1
elliot-01   Ready    master   39m   v1.19.1+k3s1
elliot-03   Ready    &lt;none&gt;   68s   v1.19.1+k3s1
</code></pre><p>Todos os elliots saudáveis!!!</p>
<p>Pronto!!! Agora temos um cluster com 3 nodes trabalhando, e as possibilidades são infinitas, divirta-se.</p>
<p>Para saber mais detalhes acesse as documentações oficiais do k3s:</p>
<ul>
<li><a href="https://k3s.io/" target="_blank">https://k3s.io/</a></li>
<li><a href="https://rancher.com/docs/k3s/latest/en/" target="_blank">https://rancher.com/docs/k3s/latest/en/</a></li>
<li><a href="https://github.com/rancher/k3s" target="_blank">https://github.com/rancher/k3s</a></li>
</ul>
<h1 id="instalação-em-cluster-com-três-nós">Instalação em cluster com três nós</h1>
<h2 id="requisitos-básicos">Requisitos básicos</h2>
<p>Como já dito anteriormente, o Minikube é ótimo para desenvolvedores, estudos e testes, mas não tem como propósito a execução em ambiente de produção. Dito isso, a instalação de um <em>cluster</em> k8s para o treinamento irá requerer pelo menos três máquinas, físicas ou virtuais, cada qual com no mínimo a seguinte configuração:</p>
<ul>
<li><p>Distribuição: Debian, Ubuntu, CentOS, Red Hat, Fedora, SuSE;</p>
</li>
<li><p>Processamento: 2 <em>cores</em>;</p>
</li>
<li><p>Memória: 2GB.</p>
</li>
</ul>
<h2 id="configuração-de-módulos-de-kernel">Configuração de módulos de kernel</h2>
<p>O k8s requer que certos módulos do kernel GNU/Linux estejam carregados para seu pleno funcionamento, e que esses módulos sejam carregados no momento da inicialização do computador. Para tanto, crie o arquivo <code>/etc/modules-load.d/k8s.conf</code> com o seguinte conteúdo em todos os seus nós.</p>
<pre><code>br_netfilter
ip_vs
ip_vs_rr
ip_vs_sh
ip_vs_wrr
nf_conntrack_ipv4
</code></pre><h2 id="atualização-da-distribuição">Atualização da distribuição</h2>
<p>Em distribuições Debian e baseadas, como o Ubuntu, execute os comandos a seguir, em cada um de seus nós, para executar atualização do sistema.</p>
<pre><code>sudo apt update

sudo apt upgrade -y
</code></pre><p>Em distribuições Red Hat e baseadas, use o seguinte comando.</p>
<pre><code>sudo yum upgrade -y
</code></pre><h2 id="instalação-do-docker-e-do-kubernetes">Instalação do Docker e do Kubernetes</h2>
<p>A instalação do Docker pode ser realizada com apenas um comando, que deve ser executado nos três nós:</p>
<pre><code>curl -fsSL https://get.docker.com | bash
</code></pre><p>Para travar a uma versão especifica do docker utilize o seguinte comando:</p>
<pre><code>export VERSION=&lt;versão do docker&gt; &amp;&amp; curl -fsSL https://get.docker.com | bash
</code></pre><p>Embora a maneira anterior seja a mais fácil, não permite o controle de opções. Por esse motivo, a documentação do Kubernetes sugere uma instalação mais controlada seguindo os passos disponíveis em: <a href="https://kubernetes.io/docs/setup/production-environment/container-runtimes/" target="_blank">https://kubernetes.io/docs/setup/production-environment/container-runtimes/</a></p>
<p><strong>Caso escolha o método mais fácil</strong>, os próximos comandos são muito importantes, pois garantem que o driver <code>Cgroup</code> do Docker será configurado para o <code>systemd</code>, que é o gerenciador de serviços padrão utilizado pelo Kubernetes.</p>
<p>Para a família Debian, execute o seguinte comando:</p>
<pre><code>cat &gt; /etc/docker/daemon.json &lt;&lt;EOF
{
  &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],
  &quot;log-driver&quot;: &quot;json-file&quot;,
  &quot;log-opts&quot;: {
    &quot;max-size&quot;: &quot;100m&quot;
  },
  &quot;storage-driver&quot;: &quot;overlay2&quot;
}
EOF
</code></pre><p>Para a família Red Hat, execute o seguinte comando:</p>
<pre><code>cat &gt; /etc/docker/daemon.json &lt;&lt;EOF
{
  &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],
  &quot;log-driver&quot;: &quot;json-file&quot;,
  &quot;log-opts&quot;: {
    &quot;max-size&quot;: &quot;100m&quot;
  },
  &quot;storage-driver&quot;: &quot;overlay2&quot;,
  &quot;storage-opts&quot;: [
    &quot;overlay2.override_kernel_check=true&quot;
  ]
}
EOF
</code></pre><p>Os passos a seguir são iguais para ambas as famílias.</p>
<pre><code>sudo mkdir -p /etc/systemd/system/docker.service.d
</code></pre><p>Agora basta reiniciar o Docker.</p>
<pre><code>sudo systemctl daemon-reload
sudo systemctl restart docker
</code></pre><p>Para finalizar, verifique se o driver <code>Cgroup</code> foi corretamente definido.</p>
<pre><code>docker info | grep -i cgroup
</code></pre><p>Se a saída foi <code>Cgroup Driver: systemd</code>, tudo certo!</p>
<p>O próximo passo é efetuar a adição dos repositórios do k8s e efetuar a instalação do <code>kubeadm</code>.</p>
<p>Em distribuições Debian e baseadas, isso pode ser realizado com os comandos a seguir.</p>
<pre><code>sudo apt-get update &amp;&amp; sudo apt-get install -y apt-transport-https gnupg2

curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -

sudo echo &quot;deb http://apt.kubernetes.io/ kubernetes-xenial main&quot; &gt; /etc/apt/sources.list.d/kubernetes.list

sudo apt-get update

sudo apt-get install -y kubelet kubeadm kubectl
</code></pre><p>Já em distribuições Red Hat e baseadas, adicione o repositório do k8s criando o arquivo <code>/etc/yum.repos.d/kubernetes.repo</code> com o conteúdo a seguir:</p>
<pre><code>[kubernetes]
name=Kubernetes
baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64
enabled=1
gpgcheck=1
repo_gpgcheck=1
gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg
</code></pre><p>Os comandos a seguir desativam o <em>firewall</em>, instalam os pacotes do k8s e ativam o serviço do mesmo.</p>
<pre><code>sudo setenforce 0

sudo systemctl stop firewalld

sudo systemctl disable firewalld

sudo yum install -y kubelet kubeadm kubectl

sudo systemctl enable docker &amp;&amp; sudo systemctl start docker

sudo systemctl enable kubelet &amp;&amp; sudo systemctl start kubelet
</code></pre><p>Ainda em distribuições Red Hat e baseadas, é necessário a configuração de alguns parâmetros extras no kernel por meio do <strong>sysctl</strong>. Estes podem ser setados criando o arquivo <code>/etc/sysctl.d/k8s.conf</code> com o seguinte conteúdo.</p>
<pre><code>net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
</code></pre><p>Em ambas distribuições GNU/Linux também é necessário desativar a memória swap em todos os nós com o comando a seguir.</p>
<pre><code>sudo swapoff -a
</code></pre><p>Além de comentar a linha referente à mesma no arquivo <code>/etc/fstab</code>.</p>
<p>Após esses procedimentos, é interessante a reinicialização de todos os nós do <em>cluster</em>.</p>
<h2 id="inicialização-do-cluster">Inicialização do cluster</h2>
<p>Antes de inicializarmos o <em>cluster</em>, vamos efetuar o <em>download</em> das imagens que serão utilizadas, executando o comando a seguir no nó que será o <em>master</em>.</p>
<pre><code>sudo kubeadm config images pull
</code></pre><p>Execute o comando a seguir também apenas no nó <em>master</em> para a inicialização do cluster. Caso tudo esteja bem, será apresentada ao término de sua execução o comando que deve ser executado nos demais nós para ingressar no <em>cluster</em>.</p>
<pre><code>sudo kubeadm init
</code></pre><p>A opção <em>--apiserver-advertise-address</em> informa qual o endereço IP em que o servidor de API irá escutar. Caso este parâmetro não seja informado, a interface de rede padrão será usada. Opcionalmente, você também pode passar o cidr com a opção <em>--pod-network-cidr</em>. O comando obedecerá a seguinte sintaxe:</p>
<pre><code>kubeadm init --apiserver-advertise-address 192.168.99.2 --pod-network-cidr 192.168.99.0/24
</code></pre><p>A saída do comando será algo similar ao mostrado a seguir.</p>
<pre><code>    [WARNING SystemVerification]: docker version is greater than the most recently validated version. Docker version: 18.05.0-ce. Max validated version: 17.03
...
To start using your cluster, you need to run the following as a regular user:

  mkdir -p $HOME/.kube
  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
  sudo chown $(id -u):$(id -g) $HOME/.kube/config
...
kubeadm join --token 39c341.a3bc3c4dd49758d5 IP_DO_MASTER:6443 --discovery-token-ca-cert-hash sha256:37092
...
</code></pre><p>Caso o servidor possua mais de uma interface de rede, você pode verificar se o IP interno do nó do seu cluster corresponde ao IP da interface esperada com o seguinte comando:</p>
<pre><code>kubectl describe node elliot-1 | grep InternalIP
</code></pre><p>A saída será algo similar a seguir:</p>
<pre><code>InternalIP:  192.168.99.2
</code></pre><p>Caso o IP não corresponda ao da interface de rede escolhida, você pode ir até o arquivo localizado em <em>/etc/systemd/system/kubelet.service.d/10-kubeadm.conf</em> com o editor da sua preferência, procure por <em>KUBELET_CONFIG_ARGS</em> e adicione no final a instrução --node-ip=<ip da sua preferência>. O trecho alterado será semelhante a esse:</ip></p>
<pre><code>Environment=&quot;KUBELET_CONFIG_ARGS=--config=/var/lib/kubelet/config.yaml --node-ip=192.168.99.2&quot;
</code></pre><p>Salve o arquivo e execute os comandos abaixo para reiniciar a configuração e consequentemente o kubelet.</p>
<pre><code>sudo systemctl daemon-reload
sudo systemctl restart kubelet
</code></pre><h2 id="configuração-do-arquivo-de-contextos-do-kubectl">Configuração do arquivo de contextos do kubectl</h2>
<p>Como dito anteriormente e de forma similar ao Docker Swarm, o próprio kubeadm já mostrará os comandos necessários para a configuração do <code>kubectl</code>, para que assim possa ser estabelecida comunicação com o cluster k8s. Para tanto, execute os seguintes comandos.</p>
<pre><code>mkdir -p $HOME/.kube

cp -i /etc/kubernetes/admin.conf $HOME/.kube/config

sudo chown $(id -u):$(id -g) $HOME/.kube/config
</code></pre><h2 id="inserindo-os-nós-workers-no-cluster">Inserindo os nós workers no cluster</h2>
<p>Para inserir os nós <em>workers</em> no <em>cluster</em>, basta executar a linha que começa com <code>kubeadm join</code> nos mesmos.</p>
<h3 id="múltiplas-interfaces">Múltiplas Interfaces</h3>
<p>Caso algum dos nós que será utilizado tenha mais de uma interface de rede, verifique se ele consegue alcançar o <code>service</code> do <code>Kubernetes</code> através da rota padrão.</p>
<p>Para verificar, será necessário pegar o IP interno do <code>service</code> Kubernetes através do comando <code>kubectl get services kubernetes</code>. Após obter o IP, basta ir no nó que será ingressado no cluster e rodar o comando <code>curl -k https://SERVICE</code> alterando o <code>SERVICE</code> para o IP do <code>service</code>. Exemplo: <code>curl -k https://10.96.0.1</code>.</p>
<p>Caso a saída seja algo parecido com o exemplo a seguir, a conexão está acontecendo normalmente.</p>
<pre><code class="lang-json">{
  <span class="hljs-string">&quot;kind&quot;</span>: <span class="hljs-string">&quot;Status&quot;</span>,
  <span class="hljs-string">&quot;apiVersion&quot;</span>: <span class="hljs-string">&quot;v1&quot;</span>,
  <span class="hljs-string">&quot;metadata&quot;</span>: {

  },
  <span class="hljs-string">&quot;status&quot;</span>: <span class="hljs-string">&quot;Failure&quot;</span>,
  <span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;forbidden: User \&quot;system:anonymous\&quot; cannot get path \&quot;/\&quot;&quot;</span>,
  <span class="hljs-string">&quot;reason&quot;</span>: <span class="hljs-string">&quot;Forbidden&quot;</span>,
  <span class="hljs-string">&quot;details&quot;</span>: {

  },
  <span class="hljs-string">&quot;code&quot;</span>: <span class="hljs-number">403</span>
}
</code></pre>
<p>Caso a saída não seja parecido com o exemplo, será necessário adicionar uma rota com o seguinte comando.</p>
<pre><code class="lang-shell">ip route add REDE_DO_SERVICE/16 dev INTERFACE
</code></pre>
<p>Substitua a <code>REDE_DO SERVICE</code> com a rede do <code>service</code> (geralmente é um IP finalizando com 0).</p>
<p>Exemplo: Se o IP for <code>10.96.0.1</code> a rede é <code>10.96.0.0</code>) e a <code>INTERFACE</code> com a interface do nó que tem acesso ao <code>master</code> do cluster.</p>
<p>Exemplo de comando para adicionar uma rota:</p>
<pre><code>sudo ip route add 10.96.0.0/16 dev eth1
</code></pre><p>Adicione a rota nas configurações de rede para que seja criada durante o boot.</p>
<h2 id="instalação-do-pod-network">Instalação do pod network</h2>
<p>Para os usuários do Docker Swarm, há uma diferença entre os dois orquestradores: o k8s por padrão não fornece uma solução de <em>networking</em> <em>out-of-the-box</em>. Para que isso ocorra, deve ser instalada uma solução de <em>pod networking</em> como <em>add-on</em>. Existem diversas opções disponíveis, cada qual com funcionalidades diferentes, tais como: <a href="https://github.com/coreos/flannel" target="_blank">Flannel</a>, <a href="http://docs.projectcalico.org/" target="_blank">Calico</a>, <a href="http://romana.io" target="_blank">Romana</a>, <a href="https://www.weave.works/products/weave-net/" target="_blank">Weave-net</a>, entre outros.</p>
<p>Mais informações sobre <em>pod networking</em> serão abordados nos demais dias do treinamento.</p>
<p>Caso você ainda não tenha reiniciado os nós que compõem o seu <em>cluster</em>, você pode carregar os módulos do kernel necessários com o seguinte comando.</p>
<pre><code>sudo modprobe br_netfilter ip_vs_rr ip_vs_wrr ip_vs_sh nf_conntrack_ipv4 ip_vs
</code></pre><p>No curso, nós iremos utilizar o <strong>Weave-net</strong>, que pode ser instalado com o comando a seguir.</p>
<pre><code>kubectl apply -f &quot;https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d &apos;\n&apos;)&quot;
</code></pre><p>Para verificar se o <em>pod network</em> foi criado com sucesso, execute o seguinte comando.</p>
<pre><code>kubectl get pods -n kube-system
</code></pre><p>O resultado deve ser semelhante ao mostrado a seguir.</p>
<pre><code>NAME                                READY   STATUS    RESTARTS   AGE
coredns-66bff467f8-pfm2c            1/1     Running   0          8d
coredns-66bff467f8-s8pk4            1/1     Running   0          8d
etcd-docker-01                      1/1     Running   0          8d
kube-apiserver-docker-01            1/1     Running   0          8d
kube-controller-manager-docker-01   1/1     Running   0          8d
kube-proxy-mdcgf                    1/1     Running   0          8d
kube-proxy-q9cvf                    1/1     Running   0          8d
kube-proxy-vf8mq                    1/1     Running   0          8d
kube-scheduler-docker-01            1/1     Running   0          8d
weave-net-7dhpf                     2/2     Running   0          8d
weave-net-fvttp                     2/2     Running   0          8d
weave-net-xl7km                     2/2     Running   0          8d
</code></pre><p>Pode-se observar que há três contêineres do Weave-net em execução provendo a <em>pod network</em> para o nosso <em>cluster</em>.</p>
<h2 id="verificando-a-instalação">Verificando a instalação</h2>
<p>Para verificar se a instalação está funcionando, e se os nós estão se comunicando, você pode executar o comando <code>kubectl get nodes</code> no nó master, que deve lhe retornar algo como o conteúdo a seguir.</p>
<pre><code>NAME        STATUS   ROLES    AGE   VERSION
elliot-01   Ready    master   8d    v1.19.1
elliot-02   Ready    &lt;none&gt;   8d    v1.19.1
elliot-03   Ready    &lt;none&gt;   8d    v1.19.1
</code></pre><h1 id="primeiros-passos-no-k8s">Primeiros passos no k8s</h1>
<h2 id="exibindo-informações-detalhadas-sobre-os-nós">Exibindo informações detalhadas sobre os nós</h2>
<pre><code>kubectl describe node [nome_do_no]
</code></pre><p>Exemplo:</p>
<pre><code>kubectl describe node elliot-02

Name:               elliot-02
Roles:              &lt;none&gt;
Labels:             beta.kubernetes.io/arch=amd64
                    beta.kubernetes.io/os=linux
                    kubernetes.io/arch=amd64
                    kubernetes.io/hostname=elliot-02
                    kubernetes.io/os=linux
Annotations:        kubeadm.alpha.kubernetes.io/cri-socket: /var/run/dockershim.sock
                    node.alpha.kubernetes.io/ttl: 0
                    volumes.kubernetes.io/controller-managed-attach-detach: true
</code></pre><h2 id="exibindo-novamente-token-para-entrar-no-cluster">Exibindo novamente token para entrar no cluster</h2>
<p>Para visualizar novamente o <em>token</em> para inserção de novos nós, execute o seguinte comando.</p>
<pre><code>sudo kubeadm token create --print-join-command
</code></pre><h2 id="ativando-o-autocomplete">Ativando o autocomplete</h2>
<p>Em distribuições Debian e baseadas, certifique-se que o pacote <code>bash-completion</code> esteja instalado. Instale-o com o comando a seguir.</p>
<pre><code>sudo apt install -y bash-completion
</code></pre><p>Em sistemas Red Hat e baseados, execute:</p>
<pre><code>sudo yum install -y bash-completion
</code></pre><p>Feito isso, execute o seguinte comando.</p>
<pre><code>kubectl completion bash &gt; /etc/bash_completion.d/kubectl
</code></pre><p>Efetue <em>logoff</em> e <em>login</em> para carregar o <em>autocomplete</em>. Caso não deseje, execute:</p>
<pre><code>source &lt;(kubectl completion bash)
</code></pre><h2 id="verificando-os-namespaces-e-pods">Verificando os namespaces e pods</h2>
<p>O k8s organiza tudo dentro de <em>namespaces</em>. Por meio deles, podem ser realizadas limitações de segurança e de recursos dentro do <em>cluster</em>, tais como <em>pods</em>, <em>replication controllers</em> e diversos outros. Para visualizar os <em>namespaces</em> disponíveis no <em>cluster</em>, digite:</p>
<pre><code>kubectl get namespaces

NAME              STATUS   AGE
default           Active   8d
kube-node-lease   Active   8d
kube-public       Active   8d
kube-system       Active   8d
</code></pre><p>Vamos listar os <em>pods</em> do <em>namespace</em> <strong>kube-system</strong> utilizando o comando a seguir.</p>
<pre><code>kubectl get pod -n kube-system

NAME                                READY   STATUS    RESTARTS   AGE
coredns-66bff467f8-pfm2c            1/1     Running   0          8d
coredns-66bff467f8-s8pk4            1/1     Running   0          8d
etcd-docker-01                      1/1     Running   0          8d
kube-apiserver-docker-01            1/1     Running   0          8d
kube-controller-manager-docker-01   1/1     Running   0          8d
kube-proxy-mdcgf                    1/1     Running   0          8d
kube-proxy-q9cvf                    1/1     Running   0          8d
kube-proxy-vf8mq                    1/1     Running   0          8d
kube-scheduler-docker-01            1/1     Running   0          8d
weave-net-7dhpf                     2/2     Running   0          8d
weave-net-fvttp                     2/2     Running   0          8d
weave-net-xl7km                     2/2     Running   0          8d
</code></pre><p>Será que há algum <em>pod</em> escondido em algum <em>namespace</em>? É possível listar todos os <em>pods</em> de todos os <em>namespaces</em> com o comando a seguir.</p>
<pre><code>kubectl get pods --all-namespaces
</code></pre><p>Há a possibilidade ainda, de utilizar o comando com a opção <code>-o wide</code>, que disponibiliza maiores informações sobre o recurso, inclusive em qual nó o <em>pod</em> está sendo executado. Exemplo:</p>
<pre><code>kubectl get pods --all-namespaces -o wide

NAMESPACE     NAME                                READY   STATUS    RESTARTS   AGE   IP             NODE        NOMINATED NODE   READINESS GATES
default       nginx                               1/1     Running   0          24m   10.44.0.1      docker-02   &lt;none&gt;           &lt;none&gt;
kube-system   coredns-66bff467f8-pfm2c            1/1     Running   0          8d    10.32.0.3      docker-01   &lt;none&gt;           &lt;none&gt;
kube-system   coredns-66bff467f8-s8pk4            1/1     Running   0          8d    10.32.0.2      docker-01   &lt;none&gt;           &lt;none&gt;
kube-system   etcd-docker-01                      1/1     Running   0          8d    172.16.83.14   docker-01   &lt;none&gt;           &lt;none&gt;
kube-system   kube-apiserver-docker-01            1/1     Running   0          8d    172.16.83.14   docker-01   &lt;none&gt;           &lt;none&gt;
kube-system   kube-controller-manager-docker-01   1/1     Running   0          8d    172.16.83.14   docker-01   &lt;none&gt;           &lt;none&gt;
kube-system   kube-proxy-mdcgf                    1/1     Running   0          8d    172.16.83.14   docker-01   &lt;none&gt;           &lt;none&gt;
kube-system   kube-proxy-q9cvf                    1/1     Running   0          8d    172.16.83.12   docker-03   &lt;none&gt;           &lt;none&gt;
kube-system   kube-proxy-vf8mq                    1/1     Running   0          8d    172.16.83.13   docker-02   &lt;none&gt;           &lt;none&gt;
kube-system   kube-scheduler-docker-01            1/1     Running   0          8d    172.16.83.14   docker-01   &lt;none&gt;           &lt;none&gt;
kube-system   weave-net-7dhpf                     2/2     Running   0          8d    172.16.83.12   docker-03   &lt;none&gt;           &lt;none&gt;
kube-system   weave-net-fvttp                     2/2     Running   0          8d    172.16.83.13   docker-02   &lt;none&gt;           &lt;none&gt;
kube-system   weave-net-xl7km                     2/2     Running   0          8d    172.16.83.14   docker-01   &lt;none&gt;           &lt;none&gt;
</code></pre><h2 id="executando-nosso-primeiro-pod-no-k8s">Executando nosso primeiro pod no k8s</h2>
<p>Iremos iniciar o nosso primeiro <em>pod</em> no k8s. Para isso, executaremos o comando a seguir.</p>
<pre><code>kubectl run nginx --image nginx

pod/nginx created
</code></pre><p>Listando os <em>pods</em> com <code>kubectl get pods</code>, obteremos a seguinte saída.</p>
<pre><code>NAME    READY   STATUS    RESTARTS   AGE
nginx   1/1     Running   0          66s
</code></pre><p>Vamos olhar agora a descrição desse objeto dentro do <em>cluster</em>.</p>
<pre><code>kubectl describe pod nginx

Name:         nginx
Namespace:    default
Priority:     0
Node:         docker-02/172.16.83.13
Start Time:   Tue, 12 May 2020 02:29:38 -0300
Labels:       run=nginx
Annotations:  &lt;none&gt;
Status:       Running
IP:           10.44.0.1
IPs:
  IP:  10.44.0.1
Containers:
  nginx:
    Container ID:   docker://2719e2bc023944ee8f34db538094c96b24764a637574c703e232908b46b12a9f
    Image:          nginx
    Image ID:       docker-pullable://nginx@sha256:86ae264c3f4acb99b2dee4d0098c40cb8c46dcf9e1148f05d3a51c4df6758c12
    Port:           &lt;none&gt;
    Host Port:      &lt;none&gt;
    State:          Running
      Started:      Tue, 12 May 2020 02:29:42 -0300
</code></pre><h2 id="verificar-os-últimos-eventos-do-cluster">Verificar os últimos eventos do cluster</h2>
<p>Você pode verificar quais são os últimos eventos do <em>cluster</em> com o comando <code>kubectl get events</code>. Serão mostrados eventos como: o <em>download</em> de imagens do Docker Hub (ou de outro <em>registry</em> configurado), a criação/remoção de <em>pods</em>, etc.</p>
<p>A saída a seguir mostra o resultado da criação do nosso contêiner com Nginx.</p>
<pre><code>LAST SEEN   TYPE     REASON      OBJECT      MESSAGE
5m34s       Normal   Scheduled   pod/nginx   Successfully assigned default/nginx to docker-02
5m33s       Normal   Pulling     pod/nginx   Pulling image &quot;nginx&quot;
5m31s       Normal   Pulled      pod/nginx   Successfully pulled image &quot;nginx&quot;
5m30s       Normal   Created     pod/nginx   Created container nginx
5m30s       Normal   Started     pod/nginx   Started container nginx
</code></pre><p>No resultado do comando anterior é possível observar que a execução do nginx ocorreu no <em>namespace</em> default e que a imagem <strong>nginx</strong> não existia no repositório local e, sendo assim, teve de ser feito download da imagem.</p>
<h2 id="efetuar-o-dump-de-um-objeto-em-formato-yaml">Efetuar o dump de um objeto em formato YAML</h2>
<p>Assim como quando se está trabalhando com <em>stacks</em> no Docker Swarm, normalmente recursos no k8s são declarados em arquivos <strong>YAML</strong> ou <strong>JSON</strong> e depois manipulados através do <code>kubectl</code>.</p>
<p>Para nos poupar o trabalho de escrever o arquivo inteiro, pode-se utilizar como <em>template</em> o <em>dump</em> de um objeto já existente no k8s, como mostrado a seguir.</p>
<pre><code>kubectl get pod nginx -o yaml &gt; meu-primeiro.yaml
</code></pre><p>Será criado um novo arquivo chamado <code>meu-primeiro.yaml</code>, resultante do redirecionamento da saída do comando <code>kubectl get pod nginx -o yaml</code>.</p>
<p>Abrindo o arquivo com <code>vim meu-primeiro.yaml</code> (você pode utilizar o editor que você preferir), teremos o seguinte conteúdo.</p>
<pre><code class="lang-yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">creationTimestamp:</span> <span class="hljs-string">&quot;2020-05-12T05:29:38Z&quot;</span>
  <span class="hljs-attr">labels:</span>
    <span class="hljs-attr">run:</span> <span class="hljs-string">nginx</span>
  <span class="hljs-attr">managedFields:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
    <span class="hljs-attr">fieldsType:</span> <span class="hljs-string">FieldsV1</span>
    <span class="hljs-attr">fieldsV1:</span>
      <span class="hljs-attr">f:metadata:</span>
        <span class="hljs-attr">f:labels:</span>
          <span class="hljs-string">.:</span> {}
          <span class="hljs-attr">f:run:</span> {}
      <span class="hljs-attr">f:spec:</span>
        <span class="hljs-attr">f:containers:</span>
          <span class="hljs-string">k:{&quot;name&quot;:&quot;nginx&quot;}:</span>
            <span class="hljs-string">.:</span> {}
            <span class="hljs-attr">f:image:</span> {}
            <span class="hljs-attr">f:imagePullPolicy:</span> {}
            <span class="hljs-attr">f:name:</span> {}
            <span class="hljs-attr">f:resources:</span> {}
            <span class="hljs-attr">f:terminationMessagePath:</span> {}
            <span class="hljs-attr">f:terminationMessagePolicy:</span> {}
        <span class="hljs-attr">f:dnsPolicy:</span> {}
        <span class="hljs-attr">f:enableServiceLinks:</span> {}
        <span class="hljs-attr">f:restartPolicy:</span> {}
        <span class="hljs-attr">f:schedulerName:</span> {}
        <span class="hljs-attr">f:securityContext:</span> {}
        <span class="hljs-attr">f:terminationGracePeriodSeconds:</span> {}
    <span class="hljs-attr">manager:</span> <span class="hljs-string">kubectl</span>
    <span class="hljs-attr">operation:</span> <span class="hljs-string">Update</span>
    <span class="hljs-attr">time:</span> <span class="hljs-string">&quot;2020-05-12T05:29:38Z&quot;</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
    <span class="hljs-attr">fieldsType:</span> <span class="hljs-string">FieldsV1</span>
    <span class="hljs-attr">fieldsV1:</span>
      <span class="hljs-attr">f:status:</span>
        <span class="hljs-attr">f:conditions:</span>
          <span class="hljs-string">k:{&quot;type&quot;:&quot;ContainersReady&quot;}:</span>
            <span class="hljs-string">.:</span> {}
            <span class="hljs-attr">f:lastProbeTime:</span> {}
            <span class="hljs-attr">f:lastTransitionTime:</span> {}
            <span class="hljs-attr">f:status:</span> {}
            <span class="hljs-attr">f:type:</span> {}
          <span class="hljs-string">k:{&quot;type&quot;:&quot;Initialized&quot;}:</span>
            <span class="hljs-string">.:</span> {}
            <span class="hljs-attr">f:lastProbeTime:</span> {}
            <span class="hljs-attr">f:lastTransitionTime:</span> {}
            <span class="hljs-attr">f:status:</span> {}
            <span class="hljs-attr">f:type:</span> {}
          <span class="hljs-string">k:{&quot;type&quot;:&quot;Ready&quot;}:</span>
            <span class="hljs-string">.:</span> {}
            <span class="hljs-attr">f:lastProbeTime:</span> {}
            <span class="hljs-attr">f:lastTransitionTime:</span> {}
            <span class="hljs-attr">f:status:</span> {}
            <span class="hljs-attr">f:type:</span> {}
        <span class="hljs-attr">f:containerStatuses:</span> {}
        <span class="hljs-attr">f:hostIP:</span> {}
        <span class="hljs-attr">f:phase:</span> {}
        <span class="hljs-attr">f:podIP:</span> {}
        <span class="hljs-attr">f:podIPs:</span>
          <span class="hljs-string">.:</span> {}
          <span class="hljs-string">k:{&quot;ip&quot;:&quot;10.44.0.1&quot;}:</span>
            <span class="hljs-string">.:</span> {}
            <span class="hljs-attr">f:ip:</span> {}
        <span class="hljs-attr">f:startTime:</span> {}
    <span class="hljs-attr">manager:</span> <span class="hljs-string">kubelet</span>
    <span class="hljs-attr">operation:</span> <span class="hljs-string">Update</span>
    <span class="hljs-attr">time:</span> <span class="hljs-string">&quot;2020-05-12T05:29:43Z&quot;</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span>
  <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span>
  <span class="hljs-attr">resourceVersion:</span> <span class="hljs-string">&quot;1673991&quot;</span>
  <span class="hljs-attr">selfLink:</span> <span class="hljs-string">/api/v1/namespaces/default/pods/nginx</span>
  <span class="hljs-attr">uid:</span> <span class="hljs-string">36506f7b-1f3b-4ee8-b063-de3e6d31bea9</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span>
    <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">Always</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span>
    <span class="hljs-attr">resources:</span> {}
    <span class="hljs-attr">terminationMessagePath:</span> <span class="hljs-string">/dev/termination-log</span>
    <span class="hljs-attr">terminationMessagePolicy:</span> <span class="hljs-string">File</span>
    <span class="hljs-attr">volumeMounts:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/var/run/secrets/kubernetes.io/serviceaccount</span>
      <span class="hljs-attr">name:</span> <span class="hljs-string">default-token-nkz89</span>
      <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span>
  <span class="hljs-attr">dnsPolicy:</span> <span class="hljs-string">ClusterFirst</span>
  <span class="hljs-attr">enableServiceLinks:</span> <span class="hljs-literal">true</span>
  <span class="hljs-attr">nodeName:</span> <span class="hljs-string">docker-02</span>
  <span class="hljs-attr">priority:</span> <span class="hljs-number">0</span>
  <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">Always</span>
  <span class="hljs-attr">schedulerName:</span> <span class="hljs-string">default-scheduler</span>
  <span class="hljs-attr">securityContext:</span> {}
  <span class="hljs-attr">serviceAccount:</span> <span class="hljs-string">default</span>
  <span class="hljs-attr">serviceAccountName:</span> <span class="hljs-string">default</span>
  <span class="hljs-attr">terminationGracePeriodSeconds:</span> <span class="hljs-number">30</span>
  <span class="hljs-attr">tolerations:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">effect:</span> <span class="hljs-string">NoExecute</span>
    <span class="hljs-attr">key:</span> <span class="hljs-string">node.kubernetes.io/not-ready</span>
    <span class="hljs-attr">operator:</span> <span class="hljs-string">Exists</span>
    <span class="hljs-attr">tolerationSeconds:</span> <span class="hljs-number">300</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">effect:</span> <span class="hljs-string">NoExecute</span>
    <span class="hljs-attr">key:</span> <span class="hljs-string">node.kubernetes.io/unreachable</span>
    <span class="hljs-attr">operator:</span> <span class="hljs-string">Exists</span>
    <span class="hljs-attr">tolerationSeconds:</span> <span class="hljs-number">300</span>
  <span class="hljs-attr">volumes:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">default-token-nkz89</span>
    <span class="hljs-attr">secret:</span>
      <span class="hljs-attr">defaultMode:</span> <span class="hljs-number">420</span>
      <span class="hljs-attr">secretName:</span> <span class="hljs-string">default-token-nkz89</span>
<span class="hljs-attr">status:</span>
  <span class="hljs-attr">conditions:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">lastProbeTime:</span> <span class="hljs-literal">null</span>
    <span class="hljs-attr">lastTransitionTime:</span> <span class="hljs-string">&quot;2020-05-12T05:29:38Z&quot;</span>
    <span class="hljs-attr">status:</span> <span class="hljs-string">&quot;True&quot;</span>
    <span class="hljs-attr">type:</span> <span class="hljs-string">Initialized</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">lastProbeTime:</span> <span class="hljs-literal">null</span>
    <span class="hljs-attr">lastTransitionTime:</span> <span class="hljs-string">&quot;2020-05-12T05:29:43Z&quot;</span>
    <span class="hljs-attr">status:</span> <span class="hljs-string">&quot;True&quot;</span>
    <span class="hljs-attr">type:</span> <span class="hljs-string">Ready</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">lastProbeTime:</span> <span class="hljs-literal">null</span>
    <span class="hljs-attr">lastTransitionTime:</span> <span class="hljs-string">&quot;2020-05-12T05:29:43Z&quot;</span>
    <span class="hljs-attr">status:</span> <span class="hljs-string">&quot;True&quot;</span>
    <span class="hljs-attr">type:</span> <span class="hljs-string">ContainersReady</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">lastProbeTime:</span> <span class="hljs-literal">null</span>
    <span class="hljs-attr">lastTransitionTime:</span> <span class="hljs-string">&quot;2020-05-12T05:29:38Z&quot;</span>
    <span class="hljs-attr">status:</span> <span class="hljs-string">&quot;True&quot;</span>
    <span class="hljs-attr">type:</span> <span class="hljs-string">PodScheduled</span>
  <span class="hljs-attr">containerStatuses:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">containerID:</span> <span class="hljs-string">docker://2719e2bc023944ee8f34db538094c96b24764a637574c703e232908b46b12a9f</span>
    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:latest</span>
    <span class="hljs-attr">imageID:</span> <span class="hljs-string">docker-pullable://nginx@sha256:86ae264c3f4acb99b2dee4d0098c40cb8c46dcf9e1148f05d3a51c4df6758c12</span>
    <span class="hljs-attr">lastState:</span> {}
    <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span>
    <span class="hljs-attr">ready:</span> <span class="hljs-literal">true</span>
    <span class="hljs-attr">restartCount:</span> <span class="hljs-number">0</span>
    <span class="hljs-attr">started:</span> <span class="hljs-literal">true</span>
    <span class="hljs-attr">state:</span>
      <span class="hljs-attr">running:</span>
        <span class="hljs-attr">startedAt:</span> <span class="hljs-string">&quot;2020-05-12T05:29:42Z&quot;</span>
  <span class="hljs-attr">hostIP:</span> <span class="hljs-number">172.16</span><span class="hljs-number">.83</span><span class="hljs-number">.13</span>
  <span class="hljs-attr">phase:</span> <span class="hljs-string">Running</span>
  <span class="hljs-attr">podIP:</span> <span class="hljs-number">10.44</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>
  <span class="hljs-attr">podIPs:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">ip:</span> <span class="hljs-number">10.44</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>
  <span class="hljs-attr">qosClass:</span> <span class="hljs-string">BestEffort</span>
  <span class="hljs-attr">startTime:</span> <span class="hljs-string">&quot;2020-05-12T05:29:38Z&quot;</span>
</code></pre>
<p>Observando o arquivo anterior, notamos que este reflete o <strong>estado</strong> do <em>pod</em>. Nós desejamos utilizar tal arquivo apenas como um modelo, e sendo assim, podemos apagar as entradas que armazenam dados de estado desse <em>pod</em>, como <em>status</em> e todas as demais configurações que são específicas dele. O arquivo final ficará com o conteúdo semelhante a este:</p>
<pre><code class="lang-yaml">  <span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
  <span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
  <span class="hljs-attr">metadata:</span>
    <span class="hljs-attr">creationTimestamp:</span> <span class="hljs-literal">null</span>
    <span class="hljs-attr">labels:</span>
      <span class="hljs-attr">run:</span> <span class="hljs-string">nginx</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span>
  <span class="hljs-attr">spec:</span>
    <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span>
      <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span>
      <span class="hljs-attr">resources:</span> {}
    <span class="hljs-attr">dnsPolicy:</span> <span class="hljs-string">ClusterFirst</span>
    <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">Always</span>
  <span class="hljs-attr">status:</span> {}
</code></pre>
<p>Vamos agora remover o nosso <em>pod</em> com o seguinte comando.</p>
<pre><code>kubectl delete pod nginx
</code></pre><p>A saída deve ser algo como:</p>
<pre><code>pod &quot;nginx&quot; deleted
</code></pre><p>Vamos recriá-lo, agora a partir do nosso arquivo YAML.</p>
<pre><code>kubectl create -f meu-primeiro.yaml

pod/nginx created
</code></pre><p>Observe que não foi necessário informar ao <code>kubectl</code> qual tipo de recurso seria criado, pois isso já está contido dentro do arquivo.</p>
<p>Listando os <em>pods</em> disponíveis com o seguinte comando.</p>
<pre><code>kubectl get pods
</code></pre><p>Deve-se obter uma saída similar à esta:</p>
<pre><code>NAME    READY   STATUS    RESTARTS   AGE
nginx   1/1     Running   0          109s
</code></pre><p>Uma outra forma de criar um arquivo de <em>template</em> é através da opção <code>--dry-run</code> do <code>kubectl</code>, com o funcionamento ligeiramente diferente dependendo do tipo de recurso que será criado. Exemplos:</p>
<p>Para a criação do template de um <em>pod</em>:</p>
<pre><code>kubectl run meu-nginx --image nginx --dry-run=client -o yaml &gt; pod-template.yaml
</code></pre><p>Para a criação do <em>template</em> de um <em>deployment</em>:</p>
<pre><code>kubectl create deployment meu-nginx --image=nginx --dry-run=client -o yaml &gt; deployment-template.yaml
</code></pre><p>A vantagem deste método é que não há a necessidade de limpar o arquivo, além de serem apresentadas apenas as opções necessárias do recurso.</p>
<h2 id="socorro-são-muitas-opções">Socorro, são muitas opções!</h2>
<p>Calma, nós sabemos. Mas o <code>kubectl</code> pode lhe auxiliar um pouco em relação a isso. Ele contém a opção <code>explain</code>, que você pode utilizar caso precise de ajuda com alguma opção em específico dos arquivos de recurso. A seguir alguns exemplos de sintaxe.</p>
<pre><code>kubectl explain [recurso]

kubectl explain [recurso.caminho.para.spec]

kubectl explain [recurso.caminho.para.spec] --recursive
</code></pre><p>Exemplos:</p>
<pre><code>kubectl explain deployment

kubectl explain pod --recursive

kubectl explain deployment.spec.template.spec
</code></pre><h2 id="expondo-o-pod">Expondo o pod</h2>
<p>Dispositivos fora do <em>cluster</em>, por padrão, não conseguem acessar os <em>pods</em> criados, como é comum em outros sistemas de contêineres. Para expor um <em>pod</em>, execute o comando a seguir.</p>
<pre><code>kubectl expose pod nginx
</code></pre><p>Será apresentada a seguinte mensagem de erro:</p>
<pre><code>error: couldn&apos;t find port via --port flag or introspection
See &apos;kubectl expose -h&apos; for help and examples
</code></pre><p>O erro ocorre devido ao fato do k8s não saber qual é a porta de destino do contêiner que deve ser exposta (no caso, a 80/TCP). Para configurá-la, vamos primeiramente remover o nosso <em>pod</em> antigo:</p>
<pre><code>kubectl delete -f meu-primeiro.yaml
</code></pre><p>Abra agora o arquivo <code>meu-primeiro.yaml</code> e adicione o bloco a seguir.</p>
<pre><code class="lang-yaml"><span class="hljs-string">...</span>
<span class="hljs-attr">spec:</span>
       <span class="hljs-attr">containers:</span>
       <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span>
         <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">Always</span>
         <span class="hljs-attr">ports:</span>
         <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span>
         <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span>
         <span class="hljs-attr">resources:</span> {}
<span class="hljs-string">...</span>
</code></pre>
<blockquote>
<p><strong>Atenção!!!</strong> Arquivos YAML utilizam para sua tabulação dois espaços e não <em>tab</em>.</p>
</blockquote>
<p>Feita a modificação no arquivo, salve-o e crie novamente o <em>pod</em> com o comando a seguir.</p>
<pre><code>kubectl create -f meu-primeiro.yaml

pod/nginx created
</code></pre><p>Liste o pod.</p>
<pre><code>kubectl get pod nginx

NAME    READY   STATUS    RESTARTS   AGE
nginx   1/1     Running   0          32s
</code></pre><p>O comando a seguir cria um objeto do k8s chamado de <em>Service</em>, que é utilizado justamente para expor <em>pods</em> para acesso externo.</p>
<pre><code>kubectl expose pod nginx
</code></pre><p>Podemos listar todos os <em>services</em> com o comando a seguir.</p>
<pre><code>kubectl get services

NAME         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGE
kubernetes   ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP   8d
nginx        ClusterIP   10.105.41.192   &lt;none&gt;        80/TCP    2m30s
</code></pre><p>Como é possível observar, há dois <em>services</em> no nosso <em>cluster</em>: o primeiro é para uso do próprio k8s, enquanto o segundo foi o quê acabamos de criar. Utilizando o <code>curl</code> contra o endereço IP mostrado na coluna <em>CLUSTER-IP</em>, deve nos ser apresentada a tela principal do Nginx.</p>
<pre><code>curl 10.105.41.192

&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Welcome to nginx!&lt;/title&gt;
&lt;style&gt;
    body {
        width: 35em;
        margin: 0 auto;
        font-family: Tahoma, Verdana, Arial, sans-serif;
    }
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;
&lt;p&gt;If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.&lt;/p&gt;

&lt;p&gt;For online documentation and support please refer to
&lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;
Commercial support is available at
&lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>Este <em>pod</em> está disponível para acesso a partir de qualquer nó do <em>cluster</em>.</p>
<h2 id="limpando-tudo-e-indo-para-casa">Limpando tudo e indo para casa</h2>
<p>Para mostrar todos os recursos recém criados, pode-se utilizar uma das seguintes opções a seguir.</p>
<pre><code>kubectl get all

kubectl get pod,service

kubectl get pod,svc
</code></pre><p>Note que o k8s nos disponibiliza algumas abreviações de seus recursos. Com o tempo você irá se familiar com elas. Para apagar os recursos criados, você pode executar os seguintes comandos.</p>
<pre><code>kubectl delete -f meu-primeiro.yaml

kubectl delete service nginx
</code></pre><p>Liste novamente os recursos para ver se os mesmos ainda estão presentes.</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="../" class="navigation navigation-prev " aria-label="Previous page: Introdução">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="../day_two/descomplicando_kubernetes.html" class="navigation navigation-next " aria-label="Next page: Descomplicando Kubernetes dia 2">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Descomplicando Kubernetes dia 1","level":"2.1","depth":1,"next":{"title":"Descomplicando Kubernetes dia 2","level":"2.2","depth":1,"path":"day_two/descomplicando_kubernetes.md","ref":"day_two/descomplicando_kubernetes.md","articles":[]},"previous":{"title":"Introdução","level":"1.1","depth":1,"path":"README.md","ref":"README.md","articles":[]},"dir":"ltr"},"config":{"plugins":[],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"language":"pt","gitbook":"*"},"file":{"path":"day_one/descomplicando_kubernetes.md","mtime":"2021-11-27T18:37:08.931Z","type":"markdown"},"gitbook":{"version":"3.6.23","time":"2021-11-27T18:37:24.087Z"},"basePath":"..","book":{"language":"pt"}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="../../gitbook/gitbook.js"></script>
    <script src="../../gitbook/theme.js"></script>
    
        
        <script src="../../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

